{
  "version": 3,
  "sources": ["../../tinymce/plugins/lists/plugin.js", "../../tinymce/plugins/lists/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 7.9.1 (2025-05-29)\n */\n\n(function () {\n    'use strict';\n\n    var global$7 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        var _a;\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType$1 = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => { };\n    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */\n    const compose1 = (fbc, fab) => (a) => fbc(fab(a));\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const tripleEquals = (a, b) => {\n        return a === b;\n    };\n    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n    function curry(fn, ...initialArgs) {\n        return (...restArgs) => {\n            const all = initialArgs.concat(restArgs);\n            return fn.apply(null, all);\n        };\n    }\n    const not = (f) => (t) => !f(t);\n    const never = constant(false);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n    // Sneaky optimisation: every instance of Optional.none is identical, so just\n    // reuse the same object\n    Optional.singletonNone = new Optional(false);\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    /* eslint-enable */\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$1 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each$1 = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const filter$1 = (xs, pred) => {\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                r.push(x);\n            }\n        }\n        return r;\n    };\n    /*\n     * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.\n     *\n     * f is a function that derives a value from an element - e.g. true or false, or a string.\n     * Elements are like if this function generates the same value for them (according to ===).\n     *\n     *\n     * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.\n     *  For a good explanation, see the group function (which is a special case of groupBy)\n     *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group\n     */\n    const groupBy = (xs, f) => {\n        if (xs.length === 0) {\n            return [];\n        }\n        else {\n            let wasType = f(xs[0]); // initial case for matching\n            const r = [];\n            let group = [];\n            for (let i = 0, len = xs.length; i < len; i++) {\n                const x = xs[i];\n                const type = f(x);\n                if (type !== wasType) {\n                    r.push(group);\n                    group = [];\n                }\n                wasType = type;\n                group.push(x);\n            }\n            if (group.length !== 0) {\n                r.push(group);\n            }\n            return r;\n        }\n    };\n    const foldl = (xs, f, acc) => {\n        each$1(xs, (x, i) => {\n            acc = f(acc, x, i);\n        });\n        return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return Optional.some(x);\n            }\n            else if (until(x, i)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n    const find = (xs, pred) => {\n        return findUntil(xs, pred, never);\n    };\n    const flatten = (xs) => {\n        // Note, this is possible because push supports multiple arguments:\n        // http://jsperf.com/concat-push/6\n        // Note that in the past, concat() would silently work (very slowly) for array-like objects.\n        // With this change it will throw an error.\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; ++i) {\n            // Ensure that each value is an array itself\n            if (!isArray(xs[i])) {\n                throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n            }\n            nativePush.apply(r, xs[i]);\n        }\n        return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const reverse = (xs) => {\n        const r = nativeSlice.call(xs, 0);\n        r.reverse();\n        return r;\n    };\n    const get$1 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = (xs) => get$1(xs, 0);\n    const last = (xs) => get$1(xs, xs.length - 1);\n    const unique = (xs, comparator) => {\n        const r = [];\n        const isDuplicated = isFunction(comparator) ?\n            (x) => exists(r, (i) => comparator(i, x)) :\n            (x) => contains$1(r, x);\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (!isDuplicated(x)) {\n                r.push(x);\n            }\n        }\n        return r;\n    };\n\n    // There are many variations of Object iteration that are faster than the 'for-in' style:\n    // http://jsperf.com/object-keys-iteration/107\n    //\n    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering\n    const keys = Object.keys;\n    const each = (obj, f) => {\n        const props = keys(obj);\n        for (let k = 0, len = props.length; k < len; k++) {\n            const i = props[k];\n            const x = obj[i];\n            f(x, i);\n        }\n    };\n    const objAcc = (r) => (x, i) => {\n        r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n        each(obj, (x, i) => {\n            (pred(x, i) ? onTrue : onFalse)(x, i);\n        });\n    };\n    const filter = (obj, pred) => {\n        const t = {};\n        internalFilter(obj, pred, objAcc(t), noop);\n        return t;\n    };\n\n    const Cell = (initial) => {\n        let value = initial;\n        const get = () => {\n            return value;\n        };\n        const set = (v) => {\n            value = v;\n        };\n        return {\n            get,\n            set\n        };\n    };\n\n    // Use window object as the global if it's available since CSP will block script evals\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    /**\n     * **Is** the value stored inside this Optional object equal to `rhs`?\n     */\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));\n    /**\n     * Are these two Optional objects equal? Equality here means either they're both\n     * `Some` (and the values are equal under the comparator) or they're both `None`.\n     */\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    /*\n    Notes on the lift functions:\n    - We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.\n    - The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.\n    - && is used instead of a loop for simplicity and performance.\n    */\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n\n    /** path :: ([String], JsObj?) -> JsObj */\n    const path = (parts, scope) => {\n        let o = scope !== undefined && scope !== null ? scope : Global;\n        for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n            o = o[parts[i]];\n        }\n        return o;\n    };\n    /** resolve :: (String, JsObj?) -> JsObj */\n    const resolve = (p, scope) => {\n        const parts = p.split('.');\n        return path(parts, scope);\n    };\n\n    const blank = (r) => (s) => s.replace(r, '');\n    /** removes all leading and trailing spaces */\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = (s) => s.length > 0;\n    const isEmpty$2 = (s) => !isNotEmpty(s);\n\n    const zeroWidth = '\\uFEFF';\n    const isZwsp = (char) => char === zeroWidth;\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom$1(node);\n    };\n    const fromDom$1 = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom: fromDom$1,\n        fromPoint\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const is$1 = (element, selector) => {\n        const dom = element.dom;\n        if (dom.nodeType !== ELEMENT) {\n            return false;\n        }\n        else {\n            const elem = dom;\n            if (elem.matches !== undefined) {\n                return elem.matches(selector);\n            }\n            else if (elem.msMatchesSelector !== undefined) {\n                return elem.msMatchesSelector(selector);\n            }\n            else if (elem.webkitMatchesSelector !== undefined) {\n                return elem.webkitMatchesSelector(selector);\n            }\n            else if (elem.mozMatchesSelector !== undefined) {\n                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib\n                return elem.mozMatchesSelector(selector);\n            }\n            else {\n                throw new Error('Browser lacks native selectors');\n            } // unfortunately we can't throw this on startup :(\n        }\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    // Returns: true if node e1 contains e2, otherwise false.\n    // (returns false if e1===e2: A node does not contain itself).\n    const contains = (e1, e2) => {\n        const d1 = e1.dom;\n        const d2 = e2.dom;\n        return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is = is$1;\n\n    const unsafe = (name, scope) => {\n        return resolve(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n        const actual = unsafe(name, scope);\n        if (actual === undefined || actual === null) {\n            throw new Error(name + ' not available on this browser');\n        }\n        return actual;\n    };\n\n    const getPrototypeOf = Object.getPrototypeOf;\n    /*\n     * IE9 and above\n     *\n     * MDN no use on this one, but here's the link anyway:\n     * https://developer.mozilla.org/en/docs/Web/API/HTMLElement\n     */\n    const sandHTMLElement = (scope) => {\n        return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = (x) => {\n        // use Resolve to get the window object for x and just return undefined if it can't find it.\n        // undefined scope later triggers using the global window.\n        const scope = resolve('ownerDocument.defaultView', x);\n        // TINY-7374: We can't rely on looking at the owner window HTMLElement as the element may have\n        // been constructed in a different window and then appended to the current window document.\n        return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf(x).constructor.name));\n    };\n\n    const name = (element) => {\n        const r = element.dom.nodeName;\n        return r.toLowerCase();\n    };\n    const type = (element) => element.dom.nodeType;\n    const isType = (t) => (element) => type(element) === t;\n    const isComment = (element) => type(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement = (element) => isElement$1(element) && isPrototypeOf(element.dom);\n    const isElement$1 = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = (tag) => (e) => isElement$1(e) && name(e) === tag;\n\n    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children = (element) => map(element.dom.childNodes, SugarElement.fromDom);\n    const child = (element, index) => {\n        const cs = element.dom.childNodes;\n        return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = (element) => child(element, 0);\n    const lastChild = (element) => child(element, element.dom.childNodes.length - 1);\n\n    /**\n     * Is the element a ShadowRoot?\n     *\n     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between\n     * a Document and a ShadowRoot.\n     */\n    const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());\n    /** If this element is in a ShadowRoot, return it. */\n    const getShadowRoot = (e) => {\n        const r = getRootNode(e);\n        return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    /** Return the host of a ShadowRoot.\n     *\n     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.\n     * If you actually have a ShadowRoot, this shouldn't happen.\n     */\n    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);\n\n    const before$1 = (marker, element) => {\n        const parent$1 = parent(marker);\n        parent$1.each((v) => {\n            v.dom.insertBefore(element.dom, marker.dom);\n        });\n    };\n    const after = (marker, element) => {\n        const sibling = nextSibling(marker);\n        sibling.fold(() => {\n            const parent$1 = parent(marker);\n            parent$1.each((v) => {\n                append$1(v, element);\n            });\n        }, (v) => {\n            before$1(v, element);\n        });\n    };\n    const prepend = (parent, element) => {\n        const firstChild$1 = firstChild(parent);\n        firstChild$1.fold(() => {\n            append$1(parent, element);\n        }, (v) => {\n            parent.dom.insertBefore(element.dom, v.dom);\n        });\n    };\n    const append$1 = (parent, element) => {\n        parent.dom.appendChild(element.dom);\n    };\n\n    const before = (marker, elements) => {\n        each$1(elements, (x) => {\n            before$1(marker, x);\n        });\n    };\n    const append = (parent, elements) => {\n        each$1(elements, (x) => {\n            append$1(parent, x);\n        });\n    };\n\n    const rawSet = (dom, key, value) => {\n        /*\n         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.\n         *\n         * We fail on those invalid cases, only allowing numbers and booleans.\n         */\n        if (isString(value) || isBoolean(value) || isNumber(value)) {\n            dom.setAttribute(key, value + '');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n            throw new Error('Attribute value was not simple');\n        }\n    };\n    const setAll = (element, attrs) => {\n        const dom = element.dom;\n        each(attrs, (v, k) => {\n            rawSet(dom, k, v);\n        });\n    };\n    const clone$1 = (element) => foldl(element.dom.attributes, (acc, attr) => {\n        acc[attr.name] = attr.value;\n        return acc;\n    }, {});\n\n    const empty = (element) => {\n        // shortcut \"empty node\" trick. Requires IE 9.\n        element.dom.textContent = '';\n        // If the contents was a single empty text node, the above doesn't remove it. But, it's still faster in general\n        // than removing every child node manually.\n        // The following is (probably) safe for performance as 99.9% of the time the trick works and\n        // Traverse.children will return an empty array.\n        each$1(children(element), (rogue) => {\n            remove(rogue);\n        });\n    };\n    const remove = (element) => {\n        const dom = element.dom;\n        if (dom.parentNode !== null) {\n            dom.parentNode.removeChild(dom);\n        }\n    };\n\n    const clone = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    /** Deep clone - everything copied including children */\n    const deep = (original) => clone(original, true);\n    /** Shallow clone, with a new tag */\n    const shallowAs = (original, tag) => {\n        const nu = SugarElement.fromTag(tag);\n        const attributes = clone$1(original);\n        setAll(nu, attributes);\n        return nu;\n    };\n    /** Change the tag name, but keep all children */\n    const mutate = (original, tag) => {\n        const nu = shallowAs(original, tag);\n        after(original, nu);\n        const children$1 = children(original);\n        append(nu, children$1);\n        remove(original);\n        return nu;\n    };\n\n    const fromDom = (nodes) => map(nodes, SugarElement.fromDom);\n\n    // some elements, such as mathml, don't have style attributes\n    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration\n    const isSupported = (dom) => \n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    // Node.contains() is very, very, very good performance\n    // http://jsperf.com/closest-vs-contains/5\n    const inBody = (element) => {\n        // Technically this is only required on IE, where contains() returns false for text nodes.\n        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).\n        const dom = isText(element) ? element.dom.parentNode : element.dom;\n        // use ownerDocument.body to ensure this works inside iframes.\n        // Normally contains is bad because an element \"contains\" itself, but here we want that.\n        if (dom === undefined || dom === null || dom.ownerDocument === null) {\n            return false;\n        }\n        const doc = dom.ownerDocument;\n        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    const internalSet = (dom, property, value) => {\n        // This is going to hurt. Apologies.\n        // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.\n        // we're going to be explicit; strings only.\n        if (!isString(value)) {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n            throw new Error('CSS value must be a string: ' + value);\n        }\n        // removed: support for dom().style[property] where prop is camel case instead of normal property name\n        if (isSupported(dom)) {\n            dom.style.setProperty(property, value);\n        }\n    };\n    const set = (element, property, value) => {\n        const dom = element.dom;\n        internalSet(dom, property, value);\n    };\n\n    const fromElements = (elements, scope) => {\n        const doc = scope || document;\n        const fragment = doc.createDocumentFragment();\n        each$1(elements, (element) => {\n            fragment.appendChild(element.dom);\n        });\n        return SugarElement.fromDom(fragment);\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n        if (is(scope, a)) {\n            return Optional.some(scope);\n        }\n        else if (isFunction(isRoot) && isRoot(scope)) {\n            return Optional.none();\n        }\n        else {\n            return ancestor(scope, a, isRoot);\n        }\n    };\n\n    const ancestor$3 = (scope, predicate, isRoot) => {\n        let element = scope.dom;\n        const stop = isFunction(isRoot) ? isRoot : never;\n        while (element.parentNode) {\n            element = element.parentNode;\n            const el = SugarElement.fromDom(element);\n            if (predicate(el)) {\n                return Optional.some(el);\n            }\n            else if (stop(el)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n        // This is required to avoid ClosestOrAncestor passing the predicate to itself\n        const is = (s, test) => test(s);\n        return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\n    };\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, (e) => is$1(e, selector), isRoot);\n    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise\n    const closest$1 = (scope, selector, isRoot) => {\n        const is = (element, selector) => is$1(element, selector);\n        return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\n    };\n\n    const closest = (target) => closest$1(target, '[contenteditable]');\n    const isEditable = (element, assumeEditable = false) => {\n        if (inBody(element)) {\n            return element.dom.isContentEditable;\n        }\n        else {\n            // Find the closest contenteditable element and check if it's editable\n            return closest(element).fold(constant(assumeEditable), (editable) => getRaw(editable) === 'true');\n        }\n    };\n    const getRaw = (element) => element.dom.contentEditable;\n\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$3(scope, predicate, isRoot).isSome();\n\n    const ancestor = (element, target) => ancestor$1(element, curry(eq, target));\n\n    var global$6 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const matchNodeName = (name) => (node) => isNonNullable(node) && node.nodeName.toLowerCase() === name;\n    const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);\n    const isTextNode$1 = (node) => isNonNullable(node) && node.nodeType === 3;\n    const isElement = (node) => isNonNullable(node) && node.nodeType === 1;\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isOlUlNode = matchNodeNames(/^(OL|UL)$/);\n    const isOlNode = matchNodeName('ol');\n    const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\n    const isDlItemNode = matchNodeNames(/^(DT|DD)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const isBr = matchNodeName('br');\n    const isFirstChild = (node) => { var _a; return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node; };\n    const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();\n    const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;\n    const isVoid = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getVoidElements();\n    const isBogusBr = (dom, node) => {\n        if (!isBr(node)) {\n            return false;\n        }\n        return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);\n    };\n    const isEmpty$1 = (dom, elm, keepBookmarks) => {\n        const empty = dom.isEmpty(elm);\n        if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {\n            return false;\n        }\n        return empty;\n    };\n    const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());\n\n    const option = (name) => (editor) => editor.options.get(name);\n    const register$3 = (editor) => {\n        const registerOption = editor.options.register;\n        registerOption('lists_indent_on_tab', {\n            processor: 'boolean',\n            default: true\n        });\n    };\n    const shouldIndentOnTab = option('lists_indent_on_tab');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n\n    const createTextBlock = (editor, contentNode, attrs = {}) => {\n        const dom = editor.dom;\n        const blockElements = editor.schema.getBlockElements();\n        const fragment = dom.createFragment();\n        const blockName = getForcedRootBlock(editor);\n        const blockAttrs = getForcedRootBlockAttrs(editor);\n        let node;\n        let textBlock;\n        let hasContentNode = false;\n        textBlock = dom.create(blockName, {\n            ...blockAttrs,\n            ...(attrs.style ? { style: attrs.style } : {})\n        });\n        if (!isBlock(contentNode.firstChild, blockElements)) {\n            fragment.appendChild(textBlock);\n        }\n        while ((node = contentNode.firstChild)) {\n            const nodeName = node.nodeName;\n            if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {\n                hasContentNode = true;\n            }\n            if (isBlock(node, blockElements)) {\n                fragment.appendChild(node);\n                textBlock = null;\n            }\n            else {\n                if (!textBlock) {\n                    textBlock = dom.create(blockName, blockAttrs);\n                    fragment.appendChild(textBlock);\n                }\n                textBlock.appendChild(node);\n            }\n        }\n        // BR is needed in empty blocks\n        if (!hasContentNode && textBlock) {\n            textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));\n        }\n        return fragment;\n    };\n\n    const DOM$2 = global$3.DOM;\n    const splitList = (editor, list, li) => {\n        const removeAndKeepBookmarks = (targetNode) => {\n            const parent = targetNode.parentNode;\n            if (parent) {\n                global$2.each(bookmarks, (node) => {\n                    parent.insertBefore(node, li.parentNode);\n                });\n            }\n            DOM$2.remove(targetNode);\n        };\n        const bookmarks = DOM$2.select('span[data-mce-type=\"bookmark\"]', list);\n        const newBlock = createTextBlock(editor, li);\n        const tmpRng = DOM$2.createRng();\n        tmpRng.setStartAfter(li);\n        tmpRng.setEndAfter(list);\n        const fragment = tmpRng.extractContents();\n        for (let node = fragment.firstChild; node; node = node.firstChild) {\n            if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {\n                DOM$2.remove(node);\n                break;\n            }\n        }\n        if (!editor.dom.isEmpty(fragment)) {\n            DOM$2.insertAfter(fragment, list);\n        }\n        DOM$2.insertAfter(newBlock, list);\n        const parent = li.parentElement;\n        if (parent && isEmpty$1(editor.dom, parent)) {\n            removeAndKeepBookmarks(parent);\n        }\n        DOM$2.remove(li);\n        if (isEmpty$1(editor.dom, list)) {\n            DOM$2.remove(list);\n        }\n    };\n\n    const isDescriptionDetail = isTag('dd');\n    const isDescriptionTerm = isTag('dt');\n    const outdentDlItem = (editor, item) => {\n        if (isDescriptionDetail(item)) {\n            mutate(item, 'dt');\n        }\n        else if (isDescriptionTerm(item)) {\n            parentElement(item).each((dl) => splitList(editor, dl.dom, item.dom));\n        }\n    };\n    const indentDlItem = (item) => {\n        if (isDescriptionTerm(item)) {\n            mutate(item, 'dd');\n        }\n    };\n    const dlIndentation = (editor, indentation, dlItems) => {\n        if (indentation === \"Indent\" /* Indentation.Indent */) {\n            each$1(dlItems, indentDlItem);\n        }\n        else {\n            each$1(dlItems, (item) => outdentDlItem(editor, item));\n        }\n    };\n\n    const getNormalizedPoint = (container, offset) => {\n        if (isTextNode$1(container)) {\n            return { container, offset };\n        }\n        const node = global$6.getNode(container, offset);\n        if (isTextNode$1(node)) {\n            return {\n                container: node,\n                offset: offset >= container.childNodes.length ? node.data.length : 0\n            };\n        }\n        else if (node.previousSibling && isTextNode$1(node.previousSibling)) {\n            return {\n                container: node.previousSibling,\n                offset: node.previousSibling.data.length\n            };\n        }\n        else if (node.nextSibling && isTextNode$1(node.nextSibling)) {\n            return {\n                container: node.nextSibling,\n                offset: 0\n            };\n        }\n        return { container, offset };\n    };\n    const normalizeRange = (rng) => {\n        const outRng = rng.cloneRange();\n        const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\n        outRng.setStart(rangeStart.container, rangeStart.offset);\n        const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\n        outRng.setEnd(rangeEnd.container, rangeEnd.offset);\n        return outRng;\n    };\n\n    const listNames = ['OL', 'UL', 'DL'];\n    const listSelector = listNames.join(',');\n    const getParentList = (editor, node) => {\n        const selectionStart = node || editor.selection.getStart(true);\n        return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));\n    };\n    const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\n    const findSubLists = (parentList) => filter$1(parentList.querySelectorAll(listSelector), isListNode);\n    const getSelectedSubLists = (editor) => {\n        const parentList = getParentList(editor);\n        const selectedBlocks = editor.selection.getSelectedBlocks();\n        if (isParentListSelected(parentList, selectedBlocks)) {\n            return findSubLists(parentList);\n        }\n        else {\n            return filter$1(selectedBlocks, (elm) => {\n                return isListNode(elm) && parentList !== elm;\n            });\n        }\n    };\n    const findParentListItemsNodes = (editor, elms) => {\n        const listItemsElms = global$2.map(elms, (elm) => {\n            const parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListHost(editor, elm));\n            return parentLi ? parentLi : elm;\n        });\n        return unique(listItemsElms);\n    };\n    const getSelectedListItems = (editor) => {\n        const selectedBlocks = editor.selection.getSelectedBlocks();\n        return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);\n    };\n    const getSelectedDlItems = (editor) => filter$1(getSelectedListItems(editor), isDlItemNode);\n    const getClosestEditingHost = (editor, elm) => {\n        const parentTableCell = editor.dom.getParents(elm, 'TD,TH');\n        return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();\n    };\n    const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, (listName) => schema.isValidChild(node.nodeName, listName));\n    const getClosestListHost = (editor, elm) => {\n        const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);\n        const isNotForcedRootBlock = (elm) => elm.nodeName.toLowerCase() !== getForcedRootBlock(editor);\n        const parentBlock = find(parentBlocks, (elm) => isNotForcedRootBlock(elm) && isListHost(editor.schema, elm));\n        return parentBlock.getOr(editor.getBody());\n    };\n    const isListInsideAnLiWithFirstAndLastNotListElement = (list) => parent(list).exists((parent) => isListItemNode(parent.dom)\n        && firstChild(parent).exists((firstChild) => !isListNode(firstChild.dom))\n        && lastChild(parent).exists((lastChild) => !isListNode(lastChild.dom)));\n    const findLastParentListNode = (editor, elm) => {\n        const parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n        return last(parentLists);\n    };\n    const getSelectedLists = (editor) => {\n        const firstList = findLastParentListNode(editor, editor.selection.getStart());\n        const subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);\n        return firstList.toArray().concat(subsequentLists);\n    };\n    const getParentLists = (editor) => {\n        const elm = editor.selection.getStart();\n        return editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n    };\n    const getSelectedListRoots = (editor) => {\n        const selectedLists = getSelectedLists(editor);\n        const parentLists = getParentLists(editor);\n        return find(parentLists, (p) => isListInsideAnLiWithFirstAndLastNotListElement(SugarElement.fromDom(p))).fold(() => getUniqueListRoots(editor, selectedLists), (l) => [l]);\n    };\n    const getUniqueListRoots = (editor, lists) => {\n        const listRoots = map(lists, (list) => findLastParentListNode(editor, list).getOr(list));\n        return unique(listRoots);\n    };\n\n    const isCustomList = (list) => /\\btox\\-/.test(list.className);\n    const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode)\n        .exists((list) => list.nodeName === listName && !isCustomList(list));\n    // Advlist/core/ListUtils.ts - Duplicated in Advlist plugin\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const selectionIsWithinNonEditableList = (editor) => {\n        const parentList = getParentList(editor);\n        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();\n    };\n    const isWithinNonEditableList = (editor, element) => {\n        const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n        const initialNode = editor.selection.getNode();\n        // Set the initial state\n        nodeChangeHandler({\n            parents: editor.dom.getParents(initialNode),\n            element: initialNode\n        });\n        editor.on('NodeChange', nodeChangeHandler);\n        return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    const fireListEvent = (editor, action, element) => editor.dispatch('ListMutation', { action, element });\n\n    const isList = (el) => is(el, 'OL,UL');\n    const isListItem = (el) => is(el, 'LI');\n    const hasFirstChildList = (el) => firstChild(el).exists(isList);\n    const hasLastChildList = (el) => lastChild(el).exists(isList);\n\n    const isEntryList = (entry) => 'listAttributes' in entry;\n    const isEntryComment = (entry) => 'isComment' in entry;\n    const isEntryFragment = (entry) => 'isFragment' in entry;\n    const isIndented = (entry) => entry.depth > 0;\n    const isSelected = (entry) => entry.isSelected;\n    const cloneItemContent = (li) => {\n        const children$1 = children(li);\n        const content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\n        return map(content, deep);\n    };\n    const createEntry = (li, depth, isSelected) => parent(li).filter(isElement$1).map((list) => ({\n        depth,\n        dirty: false,\n        isSelected,\n        content: cloneItemContent(li),\n        itemAttributes: clone$1(li),\n        listAttributes: clone$1(list),\n        listType: name(list),\n        isInPreviousLi: false\n    }));\n\n    const joinSegment = (parent, child) => {\n        append$1(parent.item, child.list);\n    };\n    const joinSegments = (segments) => {\n        for (let i = 1; i < segments.length; i++) {\n            joinSegment(segments[i - 1], segments[i]);\n        }\n    };\n    const appendSegments = (head$1, tail) => {\n        lift2(last(head$1), head(tail), joinSegment);\n    };\n    const createSegment = (scope, listType) => {\n        const segment = {\n            list: SugarElement.fromTag(listType, scope),\n            item: SugarElement.fromTag('li', scope)\n        };\n        append$1(segment.list, segment.item);\n        return segment;\n    };\n    const createSegments = (scope, entry, size) => {\n        const segments = [];\n        for (let i = 0; i < size; i++) {\n            segments.push(createSegment(scope, isEntryList(entry) ? entry.listType : entry.parentListType));\n        }\n        return segments;\n    };\n    const populateSegments = (segments, entry) => {\n        for (let i = 0; i < segments.length - 1; i++) {\n            set(segments[i].item, 'list-style-type', 'none');\n        }\n        last(segments).each((segment) => {\n            if (isEntryList(entry)) {\n                setAll(segment.list, entry.listAttributes);\n                setAll(segment.item, entry.itemAttributes);\n            }\n            append(segment.item, entry.content);\n        });\n    };\n    const normalizeSegment = (segment, entry) => {\n        if (name(segment.list) !== entry.listType) {\n            segment.list = mutate(segment.list, entry.listType);\n        }\n        setAll(segment.list, entry.listAttributes);\n    };\n    const createItem = (scope, attr, content) => {\n        const item = SugarElement.fromTag('li', scope);\n        setAll(item, attr);\n        append(item, content);\n        return item;\n    };\n    const appendItem = (segment, item) => {\n        append$1(segment.list, item);\n        segment.item = item;\n    };\n    const writeShallow = (scope, cast, entry) => {\n        const newCast = cast.slice(0, entry.depth);\n        last(newCast).each((segment) => {\n            if (isEntryList(entry)) {\n                const item = createItem(scope, entry.itemAttributes, entry.content);\n                appendItem(segment, item);\n                normalizeSegment(segment, entry);\n            }\n            else if (isEntryFragment(entry)) {\n                append(segment.item, entry.content);\n            }\n            else {\n                const item = SugarElement.fromHtml(`<!--${entry.content}-->`);\n                append$1(segment.list, item);\n            }\n        });\n        return newCast;\n    };\n    const writeDeep = (scope, cast, entry) => {\n        const segments = createSegments(scope, entry, entry.depth - cast.length);\n        joinSegments(segments);\n        populateSegments(segments, entry);\n        appendSegments(cast, segments);\n        return cast.concat(segments);\n    };\n    const composeList = (scope, entries) => {\n        let firstCommentEntryOpt = Optional.none();\n        const cast = foldl(entries, (cast, entry, i) => {\n            if (!isEntryComment(entry)) {\n                return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\n            }\n            else {\n                // this is needed becuase if the first element of the list is a comment we would not have the data to create the new list\n                if (i === 0) {\n                    firstCommentEntryOpt = Optional.some(entry);\n                    return cast;\n                }\n                return writeShallow(scope, cast, entry);\n            }\n        }, []);\n        firstCommentEntryOpt.each((firstCommentEntry) => {\n            const item = SugarElement.fromHtml(`<!--${firstCommentEntry.content}-->`);\n            head(cast).each((fistCast) => {\n                prepend(fistCast.list, item);\n            });\n        });\n        return head(cast).map((segment) => segment.list);\n    };\n\n    const indentEntry = (indentation, entry) => {\n        switch (indentation) {\n            case \"Indent\" /* Indentation.Indent */:\n                entry.depth++;\n                break;\n            case \"Outdent\" /* Indentation.Outdent */:\n                entry.depth--;\n                break;\n            case \"Flatten\" /* Indentation.Flatten */:\n                entry.depth = 0;\n        }\n        entry.dirty = true;\n    };\n\n    const cloneListProperties = (target, source) => {\n        if (isEntryList(target) && isEntryList(source)) {\n            target.listType = source.listType;\n            target.listAttributes = { ...source.listAttributes };\n        }\n    };\n    const cleanListProperties = (entry) => {\n        // Remove the start attribute if generating a new list\n        entry.listAttributes = filter(entry.listAttributes, (_value, key) => key !== 'start');\n    };\n    // Closest entry above/below in the same list\n    const closestSiblingEntry = (entries, start) => {\n        const depth = entries[start].depth;\n        // Ignore dirty items as they've been moved and won't have the right list data yet\n        const matches = (entry) => entry.depth === depth && !entry.dirty;\n        const until = (entry) => entry.depth < depth;\n        // Check in reverse to see if there's an entry as the same depth before the current entry\n        // but if not, then try to walk forwards as well\n        return findUntil(reverse(entries.slice(0, start)), matches, until)\n            .orThunk(() => findUntil(entries.slice(start + 1), matches, until));\n    };\n    const normalizeEntries = (entries) => {\n        each$1(entries, (entry, i) => {\n            closestSiblingEntry(entries, i).fold(() => {\n                if (entry.dirty && isEntryList(entry)) {\n                    cleanListProperties(entry);\n                }\n            }, (matchingEntry) => cloneListProperties(entry, matchingEntry));\n        });\n        return entries;\n    };\n\n    const parseSingleItem = (depth, itemSelection, selectionState, item) => {\n        var _a;\n        if (isComment(item)) {\n            return [{\n                    depth: depth + 1,\n                    content: (_a = item.dom.nodeValue) !== null && _a !== void 0 ? _a : '',\n                    dirty: false,\n                    isSelected: false,\n                    isComment: true\n                }];\n        }\n        itemSelection.each((selection) => {\n            if (eq(selection.start, item)) {\n                selectionState.set(true);\n            }\n        });\n        const currentItemEntry = createEntry(item, depth, selectionState.get());\n        // Update selectionState (end)\n        itemSelection.each((selection) => {\n            if (eq(selection.end, item)) {\n                selectionState.set(false);\n            }\n        });\n        const childListEntries = lastChild(item)\n            .filter(isList)\n            .map((list) => parseList(depth, itemSelection, selectionState, list))\n            .getOr([]);\n        return currentItemEntry.toArray().concat(childListEntries);\n    };\n    const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => parseSingleItem(depth, itemSelection, selectionState, item), (list) => {\n        const parsedSiblings = foldl(children(item), (acc, liChild, i) => {\n            if (i === 0) {\n                return acc;\n            }\n            else {\n                if (isListItem(liChild)) {\n                    return acc.concat(parseSingleItem(depth, itemSelection, selectionState, liChild));\n                }\n                else {\n                    const fragment = {\n                        isFragment: true,\n                        depth,\n                        content: [liChild],\n                        isSelected: false,\n                        dirty: false,\n                        parentListType: name(list)\n                    };\n                    return acc.concat(fragment);\n                }\n            }\n        }, []);\n        return parseList(depth, itemSelection, selectionState, list).concat(parsedSiblings);\n    });\n    const parseList = (depth, itemSelection, selectionState, list) => bind(children(list), (element) => {\n        const parser = isList(element) ? parseList : parseItem;\n        const newDepth = depth + 1;\n        return parser(newDepth, itemSelection, selectionState, element);\n    });\n    const parseLists = (lists, itemSelection) => {\n        const selectionState = Cell(false);\n        const initialDepth = 0;\n        return map(lists, (list) => ({\n            sourceList: list,\n            entries: parseList(initialDepth, itemSelection, selectionState, list)\n        }));\n    };\n\n    const outdentedComposer = (editor, entries) => {\n        const normalizedEntries = normalizeEntries(entries);\n        return map(normalizedEntries, (entry) => {\n            const content = !isEntryComment(entry)\n                ? fromElements(entry.content)\n                : fromElements([SugarElement.fromHtml(`<!--${entry.content}-->`)]);\n            const listItemAttrs = isEntryList(entry) ? entry.itemAttributes : {};\n            return SugarElement.fromDom(createTextBlock(editor, content.dom, listItemAttrs));\n        });\n    };\n    const indentedComposer = (editor, entries) => {\n        const normalizedEntries = normalizeEntries(entries);\n        return composeList(editor.contentDocument, normalizedEntries).toArray();\n    };\n    const composeEntries = (editor, entries) => bind(groupBy(entries, isIndented), (entries) => {\n        const groupIsIndented = head(entries).exists(isIndented);\n        return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\n    });\n    const indentSelectedEntries = (entries, indentation) => {\n        each$1(filter$1(entries, isSelected), (entry) => indentEntry(indentation, entry));\n    };\n    const getItemSelection = (editor) => {\n        const selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);\n        return lift2(find(selectedListItems, not(hasFirstChildList)), find(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({ start, end }));\n    };\n    const listIndentation = (editor, lists, indentation) => {\n        const entrySets = parseLists(lists, getItemSelection(editor));\n        each$1(entrySets, (entrySet) => {\n            indentSelectedEntries(entrySet.entries, indentation);\n            const composedLists = composeEntries(editor, entrySet.entries);\n            each$1(composedLists, (composedList) => {\n                fireListEvent(editor, indentation === \"Indent\" /* Indentation.Indent */ ? \"IndentList\" /* ListAction.IndentList */ : \"OutdentList\" /* ListAction.OutdentList */, composedList.dom);\n            });\n            before(entrySet.sourceList, composedLists);\n            remove(entrySet.sourceList);\n        });\n    };\n\n    const selectionIndentation = (editor, indentation) => {\n        const lists = fromDom(getSelectedListRoots(editor));\n        const dlItems = fromDom(getSelectedDlItems(editor));\n        let isHandled = false;\n        if (lists.length || dlItems.length) {\n            const bookmark = editor.selection.getBookmark();\n            listIndentation(editor, lists, indentation);\n            dlIndentation(editor, indentation, dlItems);\n            editor.selection.moveToBookmark(bookmark);\n            editor.selection.setRng(normalizeRange(editor.selection.getRng()));\n            editor.nodeChanged();\n            isHandled = true;\n        }\n        return isHandled;\n    };\n    const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);\n    const indentListSelection = (editor) => handleIndentation(editor, \"Indent\" /* Indentation.Indent */);\n    const outdentListSelection = (editor) => handleIndentation(editor, \"Outdent\" /* Indentation.Outdent */);\n    const flattenListSelection = (editor) => handleIndentation(editor, \"Flatten\" /* Indentation.Flatten */);\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');\n\n    const DOM$1 = global$3.DOM;\n    /**\n     * Returns a range bookmark. This will convert indexed bookmarks into temporary span elements with\n     * index 0 so that they can be restored properly after the DOM has been modified. Text bookmarks will not have spans\n     * added to them since they can be restored after a dom operation.\n     *\n     * So this: <p><b>|</b><b>|</b></p>\n     * becomes: <p><b><span data-mce-type=\"bookmark\">|</span></b><b data-mce-type=\"bookmark\">|</span></b></p>\n     *\n     * @param  {DOMRange} rng DOM Range to get bookmark on.\n     * @return {Object} Bookmark object.\n     */\n    const createBookmark = (rng) => {\n        const bookmark = {};\n        const setupEndPoint = (start) => {\n            let container = rng[start ? 'startContainer' : 'endContainer'];\n            let offset = rng[start ? 'startOffset' : 'endOffset'];\n            if (isElement(container)) {\n                const offsetNode = DOM$1.create('span', { 'data-mce-type': 'bookmark' });\n                if (container.hasChildNodes()) {\n                    offset = Math.min(offset, container.childNodes.length - 1);\n                    if (start) {\n                        container.insertBefore(offsetNode, container.childNodes[offset]);\n                    }\n                    else {\n                        DOM$1.insertAfter(offsetNode, container.childNodes[offset]);\n                    }\n                }\n                else {\n                    container.appendChild(offsetNode);\n                }\n                container = offsetNode;\n                offset = 0;\n            }\n            bookmark[start ? 'startContainer' : 'endContainer'] = container;\n            bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n        };\n        setupEndPoint(true);\n        if (!rng.collapsed) {\n            setupEndPoint();\n        }\n        return bookmark;\n    };\n    const resolveBookmark = (bookmark) => {\n        const restoreEndPoint = (start) => {\n            const nodeIndex = (container) => {\n                var _a;\n                let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;\n                let idx = 0;\n                while (node) {\n                    if (node === container) {\n                        return idx;\n                    }\n                    // Skip data-mce-type=bookmark nodes\n                    if (!isElement(node) || node.getAttribute('data-mce-type') !== 'bookmark') {\n                        idx++;\n                    }\n                    node = node.nextSibling;\n                }\n                return -1;\n            };\n            let container = bookmark[start ? 'startContainer' : 'endContainer'];\n            let offset = bookmark[start ? 'startOffset' : 'endOffset'];\n            if (!container) {\n                return;\n            }\n            if (isElement(container) && container.parentNode) {\n                const node = container;\n                offset = nodeIndex(container);\n                container = container.parentNode;\n                DOM$1.remove(node);\n                if (!container.hasChildNodes() && DOM$1.isBlock(container)) {\n                    container.appendChild(DOM$1.create('br'));\n                }\n            }\n            bookmark[start ? 'startContainer' : 'endContainer'] = container;\n            bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n        };\n        restoreEndPoint(true);\n        restoreEndPoint();\n        const rng = DOM$1.createRng();\n        rng.setStart(bookmark.startContainer, bookmark.startOffset);\n        if (bookmark.endContainer) {\n            rng.setEnd(bookmark.endContainer, bookmark.endOffset);\n        }\n        return normalizeRange(rng);\n    };\n\n    const listToggleActionFromListName = (listName) => {\n        switch (listName) {\n            case 'UL': return \"ToggleUlList\" /* ListAction.ToggleUlList */;\n            case 'OL': return \"ToggleOlList\" /* ListAction.ToggleOlList */;\n            case 'DL': return \"ToggleDLList\" /* ListAction.ToggleDLList */;\n        }\n    };\n\n    const updateListStyle = (dom, el, detail) => {\n        const type = detail['list-style-type'] ? detail['list-style-type'] : null;\n        dom.setStyle(el, 'list-style-type', type);\n    };\n    const setAttribs = (elm, attrs) => {\n        global$2.each(attrs, (value, key) => {\n            elm.setAttribute(key, value);\n        });\n    };\n    const updateListAttrs = (dom, el, detail) => {\n        setAttribs(el, detail['list-attributes']);\n        global$2.each(dom.select('li', el), (li) => {\n            setAttribs(li, detail['list-item-attributes']);\n        });\n    };\n    const updateListWithDetails = (dom, el, detail) => {\n        updateListStyle(dom, el, detail);\n        updateListAttrs(dom, el, detail);\n    };\n    const removeStyles = (dom, element, styles) => {\n        global$2.each(styles, (style) => dom.setStyle(element, style, ''));\n    };\n    const isInline = (editor, node) => isNonNullable(node) && !isBlock(node, editor.schema.getBlockElements());\n    const getEndPointNode = (editor, rng, start, root) => {\n        let container = rng[start ? 'startContainer' : 'endContainer'];\n        const offset = rng[start ? 'startOffset' : 'endOffset'];\n        // Resolve node index\n        if (isElement(container)) {\n            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        }\n        if (!start && isBr(container.nextSibling)) {\n            container = container.nextSibling;\n        }\n        const findBlockAncestor = (node) => {\n            while (!editor.dom.isBlock(node) && node.parentNode && root !== node) {\n                node = node.parentNode;\n            }\n            return node;\n        };\n        // The reason why the next two if statements exist is because when the root node is a table cell (possibly some other node types)\n        // then the highest we can go up the dom hierarchy is one level below the table cell.\n        // So what happens when we have a bunch of inline nodes and text nodes in the table cell\n        // and when the selection is collapsed inside one of the inline nodes then only that inline node (or text node) will be included\n        // in the created list because that would be one level below td node and the other inline nodes won't be included.\n        // So the fix proposed is to traverse left when looking for start node (and traverse right when looking for end node)\n        // and keep traversing as long as we have an inline or text node (same for traversing right).\n        // This way we end up including all the inline elements in the created list.\n        // For more info look at #TINY-6853\n        const findBetterContainer = (container, forward) => {\n            var _a;\n            const walker = new global$5(container, findBlockAncestor(container));\n            const dir = forward ? 'next' : 'prev';\n            let node;\n            while ((node = walker[dir]())) {\n                if (!(isVoid(editor, node) || isZwsp(node.textContent) || ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) === 0)) {\n                    return Optional.some(node);\n                }\n            }\n            return Optional.none();\n        };\n        // Traverse left to include inline/text nodes\n        if (start && isTextNode$1(container)) {\n            if (isZwsp(container.textContent)) {\n                container = findBetterContainer(container, false).getOr(container);\n            }\n            else {\n                if (container.parentNode !== null && isInline(editor, container.parentNode)) {\n                    container = container.parentNode;\n                }\n                while (container.previousSibling !== null && (isInline(editor, container.previousSibling) || isTextNode$1(container.previousSibling))) {\n                    container = container.previousSibling;\n                }\n            }\n        }\n        // Traverse right to include inline/text nodes\n        if (!start && isTextNode$1(container)) {\n            if (isZwsp(container.textContent)) {\n                container = findBetterContainer(container, true).getOr(container);\n            }\n            else {\n                if (container.parentNode !== null && isInline(editor, container.parentNode)) {\n                    container = container.parentNode;\n                }\n                while (container.nextSibling !== null && (isInline(editor, container.nextSibling) || isTextNode$1(container.nextSibling))) {\n                    container = container.nextSibling;\n                }\n            }\n        }\n        while (container.parentNode !== root) {\n            const parent = container.parentNode;\n            if (isTextBlock(editor, container)) {\n                return container;\n            }\n            if (/^(TD|TH)$/.test(parent.nodeName)) {\n                return container;\n            }\n            container = parent;\n        }\n        return container;\n    };\n    const getSelectedTextBlocks = (editor, rng, root) => {\n        const textBlocks = [];\n        const dom = editor.dom;\n        const startNode = getEndPointNode(editor, rng, true, root);\n        const endNode = getEndPointNode(editor, rng, false, root);\n        let block;\n        const siblings = [];\n        for (let node = startNode; node; node = node.nextSibling) {\n            siblings.push(node);\n            if (node === endNode) {\n                break;\n            }\n        }\n        global$2.each(siblings, (node) => {\n            var _a;\n            if (isTextBlock(editor, node)) {\n                textBlocks.push(node);\n                block = null;\n                return;\n            }\n            if (dom.isBlock(node) || isBr(node)) {\n                if (isBr(node)) {\n                    dom.remove(node);\n                }\n                block = null;\n                return;\n            }\n            const nextSibling = node.nextSibling;\n            if (global$1.isBookmarkNode(node)) {\n                if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || (!nextSibling && node.parentNode === root)) {\n                    block = null;\n                    return;\n                }\n            }\n            if (!block) {\n                block = dom.create('p');\n                (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(block, node);\n                textBlocks.push(block);\n            }\n            block.appendChild(node);\n        });\n        return textBlocks;\n    };\n    const hasCompatibleStyle = (dom, sib, detail) => {\n        const sibStyle = dom.getStyle(sib, 'list-style-type');\n        let detailStyle = detail ? detail['list-style-type'] : '';\n        detailStyle = detailStyle === null ? '' : detailStyle;\n        return sibStyle === detailStyle;\n    };\n    /*\n      Find the first element we would transform into a li-element if given no constraints.\n      If the common ancestor is higher up than that provide it as the starting-point for the search for the root instead of the first selected element.\n      This helps avoid issues with divs that should become li-elements are detected as the root when they should not be.\n    */\n    const getRootSearchStart = (editor, range) => {\n        const start = editor.selection.getStart(true);\n        const startPoint = getEndPointNode(editor, range, true, editor.getBody());\n        if (ancestor(SugarElement.fromDom(startPoint), SugarElement.fromDom(range.commonAncestorContainer))) {\n            return range.commonAncestorContainer;\n        }\n        else {\n            return start;\n        }\n    };\n    const applyList = (editor, listName, detail) => {\n        const rng = editor.selection.getRng();\n        let listItemName = 'LI';\n        const root = getClosestListHost(editor, getRootSearchStart(editor, rng));\n        const dom = editor.dom;\n        if (dom.getContentEditable(editor.selection.getNode()) === 'false') {\n            return;\n        }\n        listName = listName.toUpperCase();\n        if (listName === 'DL') {\n            listItemName = 'DT';\n        }\n        const bookmark = createBookmark(rng);\n        const selectedTextBlocks = filter$1(getSelectedTextBlocks(editor, rng, root), editor.dom.isEditable);\n        global$2.each(selectedTextBlocks, (block) => {\n            let listBlock;\n            const sibling = block.previousSibling;\n            const parent = block.parentNode;\n            if (!isListItemNode(parent)) {\n                if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\n                    listBlock = sibling;\n                    block = dom.rename(block, listItemName);\n                    sibling.appendChild(block);\n                }\n                else {\n                    listBlock = dom.create(listName);\n                    parent.insertBefore(listBlock, block);\n                    listBlock.appendChild(block);\n                    block = dom.rename(block, listItemName);\n                }\n                removeStyles(dom, block, [\n                    'margin', 'margin-right', 'margin-bottom', 'margin-left', 'margin-top',\n                    'padding', 'padding-right', 'padding-bottom', 'padding-left', 'padding-top'\n                ]);\n                updateListWithDetails(dom, listBlock, detail);\n                mergeWithAdjacentLists(editor.dom, listBlock);\n            }\n        });\n        editor.selection.setRng(resolveBookmark(bookmark));\n    };\n    const isValidLists = (list1, list2) => {\n        return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);\n    };\n    const hasSameListStyle = (dom, list1, list2) => {\n        const targetStyle = dom.getStyle(list1, 'list-style-type', true);\n        const style = dom.getStyle(list2, 'list-style-type', true);\n        return targetStyle === style;\n    };\n    const hasSameClasses = (elm1, elm2) => {\n        return elm1.className === elm2.className;\n    };\n    const shouldMerge = (dom, list1, list2) => {\n        return isValidLists(list1, list2) &&\n            // Note: isValidLists will ensure list1 and list2 are a HTMLElement. Unfortunately TypeScript doesn't\n            // support type guards on multiple variables. See https://github.com/microsoft/TypeScript/issues/26916\n            hasSameListStyle(dom, list1, list2) &&\n            hasSameClasses(list1, list2);\n    };\n    const mergeWithAdjacentLists = (dom, listBlock) => {\n        let node;\n        let sibling = listBlock.nextSibling;\n        if (shouldMerge(dom, listBlock, sibling)) {\n            const liSibling = sibling;\n            while ((node = liSibling.firstChild)) {\n                listBlock.appendChild(node);\n            }\n            dom.remove(liSibling);\n        }\n        sibling = listBlock.previousSibling;\n        if (shouldMerge(dom, listBlock, sibling)) {\n            const liSibling = sibling;\n            while ((node = liSibling.lastChild)) {\n                listBlock.insertBefore(node, listBlock.firstChild);\n            }\n            dom.remove(liSibling);\n        }\n    };\n    const updateList$1 = (editor, list, listName, detail) => {\n        if (list.nodeName !== listName) {\n            const newList = editor.dom.rename(list, listName);\n            updateListWithDetails(editor.dom, newList, detail);\n            fireListEvent(editor, listToggleActionFromListName(listName), newList);\n        }\n        else {\n            updateListWithDetails(editor.dom, list, detail);\n            fireListEvent(editor, listToggleActionFromListName(listName), list);\n        }\n    };\n    const updateCustomList = (editor, list, listName, detail) => {\n        list.classList.forEach((cls, _, classList) => {\n            if (cls.startsWith('tox-')) {\n                classList.remove(cls);\n                if (classList.length === 0) {\n                    list.removeAttribute('class');\n                }\n            }\n        });\n        if (list.nodeName !== listName) {\n            const newList = editor.dom.rename(list, listName);\n            updateListWithDetails(editor.dom, newList, detail);\n            fireListEvent(editor, listToggleActionFromListName(listName), newList);\n        }\n        else {\n            updateListWithDetails(editor.dom, list, detail);\n            fireListEvent(editor, listToggleActionFromListName(listName), list);\n        }\n    };\n    const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {\n        const parentIsList = isListNode(parentList);\n        if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n            flattenListSelection(editor);\n        }\n        else {\n            applyList(editor, listName, detail);\n            const bookmark = createBookmark(editor.selection.getRng());\n            const allLists = parentIsList ? [parentList, ...lists] : lists;\n            const updateFunction = (parentIsList && isCustomList(parentList)) ? updateCustomList : updateList$1;\n            global$2.each(allLists, (elm) => {\n                updateFunction(editor, elm, listName, detail);\n            });\n            editor.selection.setRng(resolveBookmark(bookmark));\n        }\n    };\n    const hasListStyleDetail = (detail) => {\n        return 'list-style-type' in detail;\n    };\n    const toggleSingleList = (editor, parentList, listName, detail) => {\n        if (parentList === editor.getBody()) {\n            return;\n        }\n        if (parentList) {\n            if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n                flattenListSelection(editor);\n            }\n            else {\n                const bookmark = createBookmark(editor.selection.getRng());\n                if (isCustomList(parentList)) {\n                    parentList.classList.forEach((cls, _, classList) => {\n                        if (cls.startsWith('tox-')) {\n                            classList.remove(cls);\n                            if (classList.length === 0) {\n                                parentList.removeAttribute('class');\n                            }\n                        }\n                    });\n                }\n                updateListWithDetails(editor.dom, parentList, detail);\n                const newList = editor.dom.rename(parentList, listName);\n                mergeWithAdjacentLists(editor.dom, newList);\n                editor.selection.setRng(resolveBookmark(bookmark));\n                applyList(editor, listName, detail);\n                fireListEvent(editor, listToggleActionFromListName(listName), newList);\n            }\n        }\n        else {\n            applyList(editor, listName, detail);\n            fireListEvent(editor, listToggleActionFromListName(listName), parentList);\n        }\n    };\n    const toggleList = (editor, listName, _detail) => {\n        const parentList = getParentList(editor);\n        if (isWithinNonEditableList(editor, parentList)) {\n            return;\n        }\n        const selectedSubLists = getSelectedSubLists(editor);\n        const detail = isObject(_detail) ? _detail : {};\n        if (selectedSubLists.length > 0) {\n            toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\n        }\n        else {\n            toggleSingleList(editor, parentList, listName, detail);\n        }\n    };\n\n    const DOM = global$3.DOM;\n    const normalizeList = (dom, list) => {\n        const parentNode = list.parentElement;\n        // Move UL/OL to previous LI if it's the only child of a LI\n        if (parentNode && parentNode.nodeName === 'LI' && parentNode.firstChild === list) {\n            const sibling = parentNode.previousSibling;\n            if (sibling && sibling.nodeName === 'LI') {\n                sibling.appendChild(list);\n                if (isEmpty$1(dom, parentNode)) {\n                    DOM.remove(parentNode);\n                }\n            }\n            else {\n                DOM.setStyle(parentNode, 'listStyleType', 'none');\n            }\n        }\n        // Append OL/UL to previous LI if it's in a parent OL/UL i.e. old HTML4\n        if (isListNode(parentNode)) {\n            const sibling = parentNode.previousSibling;\n            if (sibling && sibling.nodeName === 'LI') {\n                sibling.appendChild(list);\n            }\n        }\n    };\n    const normalizeLists = (dom, element) => {\n        const lists = global$2.grep(dom.select('ol,ul', element));\n        global$2.each(lists, (list) => {\n            normalizeList(dom, list);\n        });\n    };\n\n    const findNextCaretContainer = (editor, rng, isForward, root) => {\n        let node = rng.startContainer;\n        const offset = rng.startOffset;\n        if (isTextNode$1(node) && (isForward ? offset < node.data.length : offset > 0)) {\n            return node;\n        }\n        const nonEmptyBlocks = editor.schema.getNonEmptyElements();\n        if (isElement(node)) {\n            node = global$6.getNode(node, offset);\n        }\n        const walker = new global$5(node, root);\n        // Delete at <li>|<br></li> then jump over the bogus br\n        if (isForward) {\n            if (isBogusBr(editor.dom, node)) {\n                walker.next();\n            }\n        }\n        const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);\n        while ((node = walkFn())) {\n            if (node.nodeName === 'LI' && !node.hasChildNodes()) {\n                return node;\n            }\n            if (nonEmptyBlocks[node.nodeName]) {\n                return node;\n            }\n            if (isTextNode$1(node) && node.data.length > 0) {\n                return node;\n            }\n        }\n        return null;\n    };\n    const hasOnlyOneBlockChild = (dom, elm) => {\n        const childNodes = elm.childNodes;\n        return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\n    };\n    const isUnwrappable = (node) => Optional.from(node)\n        .map(SugarElement.fromDom)\n        .filter(isHTMLElement)\n        .exists((el) => isEditable(el) && !contains$1(['details'], name(el)));\n    const unwrapSingleBlockChild = (dom, elm) => {\n        if (hasOnlyOneBlockChild(dom, elm) && isUnwrappable(elm.firstChild)) {\n            dom.remove(elm.firstChild, true);\n        }\n    };\n    const moveChildren = (dom, fromElm, toElm) => {\n        let node;\n        const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\n        unwrapSingleBlockChild(dom, fromElm);\n        if (!isEmpty$1(dom, fromElm, true)) {\n            while ((node = fromElm.firstChild)) {\n                targetElm.appendChild(node);\n            }\n        }\n    };\n    const mergeLiElements = (dom, fromElm, toElm) => {\n        let listNode;\n        const ul = fromElm.parentNode;\n        if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {\n            return;\n        }\n        if (isListNode(toElm.lastChild)) {\n            listNode = toElm.lastChild;\n        }\n        if (ul === toElm.lastChild) {\n            if (isBr(ul.previousSibling)) {\n                dom.remove(ul.previousSibling);\n            }\n        }\n        const node = toElm.lastChild;\n        if (node && isBr(node) && fromElm.hasChildNodes()) {\n            dom.remove(node);\n        }\n        if (isEmpty$1(dom, toElm, true)) {\n            empty(SugarElement.fromDom(toElm));\n        }\n        moveChildren(dom, fromElm, toElm);\n        if (listNode) {\n            toElm.appendChild(listNode);\n        }\n        const contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));\n        const nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];\n        dom.remove(fromElm);\n        each$1(nestedLists, (list) => {\n            if (isEmpty$1(dom, list) && list !== dom.getRoot()) {\n                dom.remove(list);\n            }\n        });\n    };\n    const mergeIntoEmptyLi = (editor, fromLi, toLi) => {\n        empty(SugarElement.fromDom(toLi));\n        mergeLiElements(editor.dom, fromLi, toLi);\n        editor.selection.setCursorLocation(toLi, 0);\n    };\n    const mergeForward = (editor, rng, fromLi, toLi) => {\n        const dom = editor.dom;\n        if (dom.isEmpty(toLi)) {\n            mergeIntoEmptyLi(editor, fromLi, toLi);\n        }\n        else {\n            const bookmark = createBookmark(rng);\n            mergeLiElements(dom, fromLi, toLi);\n            editor.selection.setRng(resolveBookmark(bookmark));\n        }\n    };\n    const mergeBackward = (editor, rng, fromLi, toLi) => {\n        const bookmark = createBookmark(rng);\n        mergeLiElements(editor.dom, fromLi, toLi);\n        const resolvedBookmark = resolveBookmark(bookmark);\n        editor.selection.setRng(resolvedBookmark);\n    };\n    const backspaceDeleteFromListToListCaret = (editor, isForward) => {\n        const dom = editor.dom, selection = editor.selection;\n        const selectionStartElm = selection.getStart();\n        const root = getClosestEditingHost(editor, selectionStartElm);\n        const li = dom.getParent(selection.getStart(), 'LI', root);\n        if (li) {\n            const ul = li.parentElement;\n            if (ul === editor.getBody() && isEmpty$1(dom, ul)) {\n                return true;\n            }\n            const rng = normalizeRange(selection.getRng());\n            const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n            const willMergeParentIntoChild = otherLi && (isForward ? dom.isChildOf(li, otherLi) : dom.isChildOf(otherLi, li));\n            if (otherLi && otherLi !== li && !willMergeParentIntoChild) {\n                editor.undoManager.transact(() => {\n                    if (isForward) {\n                        mergeForward(editor, rng, otherLi, li);\n                    }\n                    else {\n                        if (isFirstChild(li)) {\n                            outdentListSelection(editor);\n                        }\n                        else {\n                            mergeBackward(editor, rng, li, otherLi);\n                        }\n                    }\n                });\n                return true;\n            }\n            else if (willMergeParentIntoChild && !isForward && otherLi !== li) {\n                const commonAncestorParent = rng.commonAncestorContainer.parentElement;\n                if (!commonAncestorParent || dom.isChildOf(otherLi, commonAncestorParent)) {\n                    return false;\n                }\n                editor.undoManager.transact(() => {\n                    const bookmark = createBookmark(rng);\n                    moveChildren(dom, commonAncestorParent, otherLi);\n                    commonAncestorParent.remove();\n                    const resolvedBookmark = resolveBookmark(bookmark);\n                    editor.selection.setRng(resolvedBookmark);\n                });\n                return true;\n            }\n            else if (!otherLi) {\n                if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {\n                    editor.undoManager.transact(() => {\n                        flattenListSelection(editor);\n                    });\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    const removeBlock = (dom, block, root) => {\n        const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\n        dom.remove(block);\n        if (parentBlock && dom.isEmpty(parentBlock)) {\n            dom.remove(parentBlock);\n        }\n    };\n    const backspaceDeleteIntoListCaret = (editor, isForward) => {\n        const dom = editor.dom;\n        const selectionStartElm = editor.selection.getStart();\n        const root = getClosestEditingHost(editor, selectionStartElm);\n        const block = dom.getParent(selectionStartElm, dom.isBlock, root);\n        if (block && dom.isEmpty(block, undefined, { checkRootAsContent: true })) {\n            const rng = normalizeRange(editor.selection.getRng());\n            const nextCaretContainer = findNextCaretContainer(editor, rng, isForward, root);\n            const otherLi = dom.getParent(nextCaretContainer, 'LI', root);\n            if (nextCaretContainer && otherLi) {\n                const findValidElement = (element) => contains$1(['td', 'th', 'caption'], name(element));\n                const findRoot = (node) => node.dom === root;\n                const otherLiCell = closest$2(SugarElement.fromDom(otherLi), findValidElement, findRoot);\n                const caretCell = closest$2(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot);\n                if (!equals(otherLiCell, caretCell, eq)) {\n                    return false;\n                }\n                editor.undoManager.transact(() => {\n                    const parentNode = otherLi.parentNode;\n                    removeBlock(dom, block, root);\n                    mergeWithAdjacentLists(dom, parentNode);\n                    editor.selection.select(nextCaretContainer, true);\n                    editor.selection.collapse(isForward);\n                });\n                return true;\n            }\n        }\n        return false;\n    };\n    const backspaceDeleteCaret = (editor, isForward) => {\n        return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\n    };\n    const hasListSelection = (editor) => {\n        const selectionStartElm = editor.selection.getStart();\n        const root = getClosestEditingHost(editor, selectionStartElm);\n        const startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);\n        return startListParent || getSelectedListItems(editor).length > 0;\n    };\n    const backspaceDeleteRange = (editor) => {\n        if (hasListSelection(editor)) {\n            editor.undoManager.transact(() => {\n                // Some delete actions may prevent the input event from being fired. If we do not detect it, we fire it ourselves.\n                let shouldFireInput = true;\n                const inputHandler = () => shouldFireInput = false;\n                editor.on('input', inputHandler);\n                editor.execCommand('Delete');\n                editor.off('input', inputHandler);\n                if (shouldFireInput) {\n                    editor.dispatch('input');\n                }\n                normalizeLists(editor.dom, editor.getBody());\n            });\n            return true;\n        }\n        return false;\n    };\n    const backspaceDelete = (editor, isForward) => {\n        const selection = editor.selection;\n        return !isWithinNonEditableList(editor, selection.getNode()) && (selection.isCollapsed() ?\n            backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor));\n    };\n    const setup$2 = (editor) => {\n        editor.on('ExecCommand', (e) => {\n            const cmd = e.command.toLowerCase();\n            if ((cmd === 'delete' || cmd === 'forwarddelete') && hasListSelection(editor)) {\n                normalizeLists(editor.dom, editor.getBody());\n            }\n        });\n        editor.on('keydown', (e) => {\n            if (e.keyCode === global$4.BACKSPACE) {\n                if (backspaceDelete(editor, false)) {\n                    e.preventDefault();\n                }\n            }\n            else if (e.keyCode === global$4.DELETE) {\n                if (backspaceDelete(editor, true)) {\n                    e.preventDefault();\n                }\n            }\n        });\n    };\n\n    const get = (editor) => ({\n        backspaceDelete: (isForward) => {\n            backspaceDelete(editor, isForward);\n        }\n    });\n\n    const updateList = (editor, update) => {\n        const parentList = getParentList(editor);\n        if (parentList === null || isWithinNonEditableList(editor, parentList)) {\n            return;\n        }\n        editor.undoManager.transact(() => {\n            if (isObject(update.styles)) {\n                editor.dom.setStyles(parentList, update.styles);\n            }\n            if (isObject(update.attrs)) {\n                each(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));\n            }\n        });\n    };\n\n    // Example: 'AB' -> 28\n    const parseAlphabeticBase26 = (str) => {\n        const chars = reverse(trim(str).split(''));\n        const values = map(chars, (char, i) => {\n            const charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n            return Math.pow(26, i) * charValue;\n        });\n        return foldl(values, (sum, v) => sum + v, 0);\n    };\n    // Example: 28 -> 'AB'\n    const composeAlphabeticBase26 = (value) => {\n        value--;\n        if (value < 0) {\n            return '';\n        }\n        else {\n            const remainder = value % 26;\n            const quotient = Math.floor(value / 26);\n            const rest = composeAlphabeticBase26(quotient);\n            const char = String.fromCharCode('A'.charCodeAt(0) + remainder);\n            return rest + char;\n        }\n    };\n    const isUppercase = (str) => /^[A-Z]+$/.test(str);\n    const isLowercase = (str) => /^[a-z]+$/.test(str);\n    const isNumeric = (str) => /^[0-9]+$/.test(str);\n    const deduceListType = (start) => {\n        if (isNumeric(start)) {\n            return 2 /* ListType.Numeric */;\n        }\n        else if (isUppercase(start)) {\n            return 0 /* ListType.UpperAlpha */;\n        }\n        else if (isLowercase(start)) {\n            return 1 /* ListType.LowerAlpha */;\n        }\n        else if (isEmpty$2(start)) {\n            return 3 /* ListType.None */;\n        }\n        else {\n            return 4 /* ListType.Unknown */;\n        }\n    };\n    const parseStartValue = (start) => {\n        switch (deduceListType(start)) {\n            case 2 /* ListType.Numeric */:\n                return Optional.some({\n                    listStyleType: Optional.none(),\n                    start\n                });\n            case 0 /* ListType.UpperAlpha */:\n                return Optional.some({\n                    listStyleType: Optional.some('upper-alpha'),\n                    start: parseAlphabeticBase26(start).toString()\n                });\n            case 1 /* ListType.LowerAlpha */:\n                return Optional.some({\n                    listStyleType: Optional.some('lower-alpha'),\n                    start: parseAlphabeticBase26(start).toString()\n                });\n            case 3 /* ListType.None */:\n                return Optional.some({\n                    listStyleType: Optional.none(),\n                    start: ''\n                });\n            case 4 /* ListType.Unknown */:\n                return Optional.none();\n        }\n    };\n    const parseDetail = (detail) => {\n        const start = parseInt(detail.start, 10);\n        if (is$2(detail.listStyleType, 'upper-alpha')) {\n            return composeAlphabeticBase26(start);\n        }\n        else if (is$2(detail.listStyleType, 'lower-alpha')) {\n            return composeAlphabeticBase26(start).toLowerCase();\n        }\n        else {\n            return detail.start;\n        }\n    };\n\n    const open = (editor) => {\n        // Find the current list and skip opening if the selection isn't in an ordered list\n        const currentList = getParentList(editor);\n        if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) {\n            return;\n        }\n        editor.windowManager.open({\n            title: 'List Properties',\n            body: {\n                type: 'panel',\n                items: [\n                    {\n                        type: 'input',\n                        name: 'start',\n                        label: 'Start list at number',\n                        inputMode: 'numeric'\n                    }\n                ]\n            },\n            initialData: {\n                start: parseDetail({\n                    start: editor.dom.getAttrib(currentList, 'start', '1'),\n                    listStyleType: Optional.from(editor.dom.getStyle(currentList, 'list-style-type'))\n                })\n            },\n            buttons: [\n                {\n                    type: 'cancel',\n                    name: 'cancel',\n                    text: 'Cancel'\n                },\n                {\n                    type: 'submit',\n                    name: 'save',\n                    text: 'Save',\n                    primary: true\n                }\n            ],\n            onSubmit: (api) => {\n                const data = api.getData();\n                parseStartValue(data.start).each((detail) => {\n                    editor.execCommand('mceListUpdate', false, {\n                        attrs: {\n                            start: detail.start === '1' ? '' : detail.start\n                        },\n                        styles: {\n                            'list-style-type': detail.listStyleType.getOr('')\n                        }\n                    });\n                });\n                api.close();\n            }\n        });\n    };\n\n    const queryListCommandState = (editor, listName) => () => {\n        const parentList = getParentList(editor);\n        return isNonNullable(parentList) && parentList.nodeName === listName;\n    };\n    const registerDialog = (editor) => {\n        editor.addCommand('mceListProps', () => {\n            open(editor);\n        });\n    };\n    const register$2 = (editor) => {\n        editor.on('BeforeExecCommand', (e) => {\n            const cmd = e.command.toLowerCase();\n            if (cmd === 'indent') {\n                indentListSelection(editor);\n            }\n            else if (cmd === 'outdent') {\n                outdentListSelection(editor);\n            }\n        });\n        editor.addCommand('InsertUnorderedList', (ui, detail) => {\n            toggleList(editor, 'UL', detail);\n        });\n        editor.addCommand('InsertOrderedList', (ui, detail) => {\n            toggleList(editor, 'OL', detail);\n        });\n        editor.addCommand('InsertDefinitionList', (ui, detail) => {\n            toggleList(editor, 'DL', detail);\n        });\n        editor.addCommand('RemoveList', () => {\n            flattenListSelection(editor);\n        });\n        registerDialog(editor);\n        editor.addCommand('mceListUpdate', (ui, detail) => {\n            if (isObject(detail)) {\n                updateList(editor, detail);\n            }\n        });\n        editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));\n        editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));\n        editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.html.Node');\n\n    const isTextNode = (node) => node.type === 3;\n    const isEmpty = (nodeBuffer) => nodeBuffer.length === 0;\n    const wrapInvalidChildren = (list) => {\n        const insertListItem = (buffer, refNode) => {\n            const li = global.create('li');\n            each$1(buffer, (node) => li.append(node));\n            if (refNode) {\n                list.insert(li, refNode, true);\n            }\n            else {\n                list.append(li);\n            }\n        };\n        const reducer = (buffer, node) => {\n            if (isTextNode(node)) {\n                return [...buffer, node];\n            }\n            else if (!isEmpty(buffer) && !isTextNode(node)) {\n                insertListItem(buffer, node);\n                return [];\n            }\n            else {\n                return buffer;\n            }\n        };\n        const restBuffer = foldl(list.children(), reducer, []);\n        if (!isEmpty(restBuffer)) {\n            insertListItem(restBuffer);\n        }\n    };\n    const setup$1 = (editor) => {\n        editor.on('PreInit', () => {\n            const { parser } = editor;\n            parser.addNodeFilter('ul,ol', (nodes) => each$1(nodes, wrapInvalidChildren));\n        });\n    };\n\n    const setupTabKey = (editor) => {\n        editor.on('keydown', (e) => {\n            // Check for tab but not ctrl/cmd+tab since it switches browser tabs\n            if (e.keyCode !== global$4.TAB || global$4.metaKeyPressed(e)) {\n                return;\n            }\n            editor.undoManager.transact(() => {\n                if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\n                    e.preventDefault();\n                }\n            });\n        });\n    };\n    const setup = (editor) => {\n        if (shouldIndentOnTab(editor)) {\n            setupTabKey(editor);\n        }\n        setup$2(editor);\n    };\n\n    const setupToggleButtonHandler = (editor, listName) => (api) => {\n        const toggleButtonHandler = (e) => {\n            api.setActive(inList(e.parents, listName));\n            api.setEnabled(!isWithinNonEditableList(editor, e.element) && editor.selection.isEditable());\n        };\n        api.setEnabled(editor.selection.isEditable());\n        return setNodeChangeHandler(editor, toggleButtonHandler);\n    };\n    const register$1 = (editor) => {\n        const exec = (command) => () => editor.execCommand(command);\n        if (!editor.hasPlugin('advlist')) {\n            editor.ui.registry.addToggleButton('numlist', {\n                icon: 'ordered-list',\n                active: false,\n                tooltip: 'Numbered list',\n                onAction: exec('InsertOrderedList'),\n                onSetup: setupToggleButtonHandler(editor, 'OL')\n            });\n            editor.ui.registry.addToggleButton('bullist', {\n                icon: 'unordered-list',\n                active: false,\n                tooltip: 'Bullet list',\n                onAction: exec('InsertUnorderedList'),\n                onSetup: setupToggleButtonHandler(editor, 'UL')\n            });\n        }\n    };\n\n    const setupMenuButtonHandler = (editor, listName) => (api) => {\n        const menuButtonHandler = (e) => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));\n        return setNodeChangeHandler(editor, menuButtonHandler);\n    };\n    const register = (editor) => {\n        const listProperties = {\n            text: 'List properties...',\n            icon: 'ordered-list',\n            onAction: () => editor.execCommand('mceListProps'),\n            onSetup: setupMenuButtonHandler(editor, 'OL')\n        };\n        editor.ui.registry.addMenuItem('listprops', listProperties);\n        editor.ui.registry.addContextMenu('lists', {\n            update: (node) => {\n                const parentList = getParentList(editor, node);\n                return isOlNode(parentList) ? ['listprops'] : [];\n            }\n        });\n    };\n\n    var Plugin = () => {\n        global$7.add('lists', (editor) => {\n            register$3(editor);\n            setup$1(editor);\n            if (!editor.hasPlugin('rtc', true)) {\n                setup(editor);\n                register$2(editor);\n            }\n            else {\n                registerDialog(editor);\n            }\n            register$1(editor);\n            register(editor);\n            return get(editor);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"lists\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/lists')\n//   ES2015:\n//     import 'tinymce/plugins/lists'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["type", "get", "set", "name", "parent", "is", "ancestor", "selector", "empty", "elm", "firstChild", "lastChild", "isSelected", "child", "cast", "entries", "container", "nextSibling", "contains$1"]
}
