{
  "version": 3,
  "sources": ["../../tinymce/plugins/table/plugin.js", "../../tinymce/plugins/table/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 7.9.1 (2025-05-29)\n */\n\n(function () {\n    'use strict';\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        var _a;\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType$1 = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const eq$1 = (t) => (a) => t === a;\n    const isString = isType$1('string');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => { };\n    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */\n    const compose1 = (fbc, fab) => (a) => fbc(fab(a));\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const identity = (x) => {\n        return x;\n    };\n    const tripleEquals = (a, b) => {\n        return a === b;\n    };\n    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n    function curry(fn, ...initialArgs) {\n        return (...restArgs) => {\n            const all = initialArgs.concat(restArgs);\n            return fn.apply(null, all);\n        };\n    }\n    const call = (f) => {\n        f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n    // Sneaky optimisation: every instance of Optional.none is identical, so just\n    // reuse the same object\n    Optional.singletonNone = new Optional(false);\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    /* eslint-enable */\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const range = (num, f) => {\n        const r = [];\n        for (let i = 0; i < num; i++) {\n            r.push(f(i));\n        }\n        return r;\n    };\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each$1 = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const eachr = (xs, f) => {\n        for (let i = xs.length - 1; i >= 0; i--) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const partition = (xs, pred) => {\n        const pass = [];\n        const fail = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            const arr = pred(x, i) ? pass : fail;\n            arr.push(x);\n        }\n        return { pass, fail };\n    };\n    const filter$1 = (xs, pred) => {\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                r.push(x);\n            }\n        }\n        return r;\n    };\n    const foldr = (xs, f, acc) => {\n        eachr(xs, (x, i) => {\n            acc = f(acc, x, i);\n        });\n        return acc;\n    };\n    const foldl = (xs, f, acc) => {\n        each$1(xs, (x, i) => {\n            acc = f(acc, x, i);\n        });\n        return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return Optional.some(x);\n            }\n            else if (until(x, i)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n    const find = (xs, pred) => {\n        return findUntil(xs, pred, never);\n    };\n    const findIndex = (xs, pred) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return Optional.some(i);\n            }\n        }\n        return Optional.none();\n    };\n    const flatten$1 = (xs) => {\n        // Note, this is possible because push supports multiple arguments:\n        // http://jsperf.com/concat-push/6\n        // Note that in the past, concat() would silently work (very slowly) for array-like objects.\n        // With this change it will throw an error.\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; ++i) {\n            // Ensure that each value is an array itself\n            if (!isArray(xs[i])) {\n                throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n            }\n            nativePush.apply(r, xs[i]);\n        }\n        return r;\n    };\n    const bind = (xs, f) => flatten$1(map(xs, f));\n    const forall = (xs, pred) => {\n        for (let i = 0, len = xs.length; i < len; ++i) {\n            const x = xs[i];\n            if (pred(x, i) !== true) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const mapToObject = (xs, f) => {\n        const r = {};\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            r[String(x)] = f(x, i);\n        }\n        return r;\n    };\n    const get$4 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = (xs) => get$4(xs, 0);\n    const last = (xs) => get$4(xs, xs.length - 1);\n    isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n        for (let i = 0; i < arr.length; i++) {\n            const r = f(arr[i], i);\n            if (r.isSome()) {\n                return r;\n            }\n        }\n        return Optional.none();\n    };\n\n    // There are many variations of Object iteration that are faster than the 'for-in' style:\n    // http://jsperf.com/object-keys-iteration/107\n    //\n    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering\n    const keys = Object.keys;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const hasOwnProperty = Object.hasOwnProperty;\n    const each = (obj, f) => {\n        const props = keys(obj);\n        for (let k = 0, len = props.length; k < len; k++) {\n            const i = props[k];\n            const x = obj[i];\n            f(x, i);\n        }\n    };\n    const objAcc = (r) => (x, i) => {\n        r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n        each(obj, (x, i) => {\n            (pred(x, i) ? onTrue : onFalse)(x, i);\n        });\n    };\n    const filter = (obj, pred) => {\n        const t = {};\n        internalFilter(obj, pred, objAcc(t), noop);\n        return t;\n    };\n    const mapToArray = (obj, f) => {\n        const r = [];\n        each(obj, (value, name) => {\n            r.push(f(value, name));\n        });\n        return r;\n    };\n    const values = (obj) => {\n        return mapToArray(obj, identity);\n    };\n    const size = (obj) => {\n        return keys(obj).length;\n    };\n    const get$3 = (obj, key) => {\n        return has(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has = (obj, key) => hasOwnProperty.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const isEmpty$1 = (r) => {\n        for (const x in r) {\n            if (hasOwnProperty.call(r, x)) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    const Cell = (initial) => {\n        let value = initial;\n        const get = () => {\n            return value;\n        };\n        const set = (v) => {\n            value = v;\n        };\n        return {\n            get,\n            set\n        };\n    };\n\n    /**\n     * **Is** the value stored inside this Optional object equal to `rhs`?\n     */\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));\n    const cat = (arr) => {\n        const r = [];\n        const push = (x) => {\n            r.push(x);\n        };\n        for (let i = 0; i < arr.length; i++) {\n            arr[i].each(push);\n        }\n        return r;\n    };\n    /*\n    Notes on the lift functions:\n    - We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.\n    - The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.\n    - && is used instead of a loop for simplicity and performance.\n    */\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const flatten = (oot) => oot.bind(identity);\n    // This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const singleton = (doRevoke) => {\n        const subject = Cell(Optional.none());\n        const revoke = () => subject.get().each(doRevoke);\n        const clear = () => {\n            revoke();\n            subject.set(Optional.none());\n        };\n        const isSet = () => subject.get().isSome();\n        const get = () => subject.get();\n        const set = (s) => {\n            revoke();\n            subject.set(Optional.some(s));\n        };\n        return {\n            clear,\n            isSet,\n            get,\n            set\n        };\n    };\n    const unbindable = () => singleton((s) => s.unbind());\n\n    const removeFromStart = (str, numChars) => {\n        return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n        return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    /** Does 'str' start with 'prefix'?\n     *  Note: all strings start with the empty string.\n     *        More formally, for all strings x, startsWith(x, \"\").\n     *        This is so that for all strings x and y, startsWith(y + x, y)\n     */\n    const startsWith = (str, prefix) => {\n        return checkRange(str, prefix, 0);\n    };\n    const blank = (r) => (s) => s.replace(r, '');\n    /** removes all leading and trailing spaces */\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = (s) => s.length > 0;\n    const isEmpty = (s) => !isNotEmpty(s);\n    const toInt = (value, radix = 10) => {\n        const num = parseInt(value, radix);\n        return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n    const toFloat = (value) => {\n        const num = parseFloat(value);\n        return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const cached = (f) => {\n        let called = false;\n        let r;\n        return (...args) => {\n            if (!called) {\n                called = true;\n                r = f.apply(null, args);\n            }\n            return r;\n        };\n    };\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom$1(node);\n    };\n    const fromDom$1 = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom: fromDom$1,\n        fromPoint\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const is$1 = (element, selector) => {\n        const dom = element.dom;\n        if (dom.nodeType !== ELEMENT) {\n            return false;\n        }\n        else {\n            const elem = dom;\n            if (elem.matches !== undefined) {\n                return elem.matches(selector);\n            }\n            else if (elem.msMatchesSelector !== undefined) {\n                return elem.msMatchesSelector(selector);\n            }\n            else if (elem.webkitMatchesSelector !== undefined) {\n                return elem.webkitMatchesSelector(selector);\n            }\n            else if (elem.mozMatchesSelector !== undefined) {\n                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib\n                return elem.mozMatchesSelector(selector);\n            }\n            else {\n                throw new Error('Browser lacks native selectors');\n            } // unfortunately we can't throw this on startup :(\n        }\n    };\n    const bypassSelector = (dom) => \n    // Only elements, documents and shadow roots support querySelector\n    // shadow root element type is DOCUMENT_FRAGMENT\n    dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT ||\n        // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/\n        dom.childElementCount === 0;\n    const all$1 = (selector, scope) => {\n        const base = scope === undefined ? document : scope.dom;\n        return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n        const base = scope === undefined ? document : scope.dom;\n        return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const is = is$1;\n\n    const name = (element) => {\n        const r = element.dom.nodeName;\n        return r.toLowerCase();\n    };\n    const type = (element) => element.dom.nodeType;\n    const isType = (t) => (element) => type(element) === t;\n    const isComment = (element) => type(element) === COMMENT || name(element) === '#comment';\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = (tag) => (e) => isElement(e) && name(e) === tag;\n\n    /**\n     * The document associated with the current element\n     * NOTE: this will throw if the owner is null.\n     */\n    const owner = (element) => SugarElement.fromDom(element.dom.ownerDocument);\n    /**\n     * If the element is a document, return it. Otherwise, return its ownerDocument.\n     * @param dos\n     */\n    const documentOrOwner = (dos) => isDocument(dos) ? dos : owner(dos);\n    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parents = (element, isRoot) => {\n        const stop = isFunction(isRoot) ? isRoot : never;\n        // This is used a *lot* so it needs to be performant, not recursive\n        let dom = element.dom;\n        const ret = [];\n        while (dom.parentNode !== null && dom.parentNode !== undefined) {\n            const rawParent = dom.parentNode;\n            const p = SugarElement.fromDom(rawParent);\n            ret.push(p);\n            if (stop(p) === true) {\n                break;\n            }\n            else {\n                dom = rawParent;\n            }\n        }\n        return ret;\n    };\n    const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children$3 = (element) => map(element.dom.childNodes, SugarElement.fromDom);\n    const child$3 = (element, index) => {\n        const cs = element.dom.childNodes;\n        return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = (element) => child$3(element, 0);\n\n    /**\n     * Is the element a ShadowRoot?\n     *\n     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between\n     * a Document and a ShadowRoot.\n     */\n    const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());\n    /** If this element is in a ShadowRoot, return it. */\n    const getShadowRoot = (e) => {\n        const r = getRootNode(e);\n        return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    /** Return the host of a ShadowRoot.\n     *\n     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.\n     * If you actually have a ShadowRoot, this shouldn't happen.\n     */\n    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);\n\n    const before = (marker, element) => {\n        const parent$1 = parent(marker);\n        parent$1.each((v) => {\n            v.dom.insertBefore(element.dom, marker.dom);\n        });\n    };\n    const after$1 = (marker, element) => {\n        const sibling = nextSibling(marker);\n        sibling.fold(() => {\n            const parent$1 = parent(marker);\n            parent$1.each((v) => {\n                append$1(v, element);\n            });\n        }, (v) => {\n            before(v, element);\n        });\n    };\n    const prepend = (parent, element) => {\n        const firstChild$1 = firstChild(parent);\n        firstChild$1.fold(() => {\n            append$1(parent, element);\n        }, (v) => {\n            parent.dom.insertBefore(element.dom, v.dom);\n        });\n    };\n    const append$1 = (parent, element) => {\n        parent.dom.appendChild(element.dom);\n    };\n    const wrap = (element, wrapper) => {\n        before(element, wrapper);\n        append$1(wrapper, element);\n    };\n\n    const after = (marker, elements) => {\n        each$1(elements, (x, i) => {\n            const e = i === 0 ? marker : elements[i - 1];\n            after$1(e, x);\n        });\n    };\n    const append = (parent, elements) => {\n        each$1(elements, (x) => {\n            append$1(parent, x);\n        });\n    };\n\n    const rawSet = (dom, key, value) => {\n        /*\n         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.\n         *\n         * We fail on those invalid cases, only allowing numbers and booleans.\n         */\n        if (isString(value) || isBoolean(value) || isNumber(value)) {\n            dom.setAttribute(key, value + '');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n            throw new Error('Attribute value was not simple');\n        }\n    };\n    const set$2 = (element, key, value) => {\n        rawSet(element.dom, key, value);\n    };\n    const setAll = (element, attrs) => {\n        const dom = element.dom;\n        each(attrs, (v, k) => {\n            rawSet(dom, k, v);\n        });\n    };\n    const get$2 = (element, key) => {\n        const v = element.dom.getAttribute(key);\n        // undefined is the more appropriate value for JS, and this matches JQuery\n        return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$2(element, key));\n    const remove$2 = (element, key) => {\n        element.dom.removeAttribute(key);\n    };\n    const clone = (element) => foldl(element.dom.attributes, (acc, attr) => {\n        acc[attr.name] = attr.value;\n        return acc;\n    }, {});\n\n    const remove$1 = (element) => {\n        const dom = element.dom;\n        if (dom.parentNode !== null) {\n            dom.parentNode.removeChild(dom);\n        }\n    };\n    const unwrap = (wrapper) => {\n        const children = children$3(wrapper);\n        if (children.length > 0) {\n            after(wrapper, children);\n        }\n        remove$1(wrapper);\n    };\n\n    const fromDom = (nodes) => map(nodes, SugarElement.fromDom);\n\n    // some elements, such as mathml, don't have style attributes\n    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration\n    const isSupported = (dom) => \n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    // Node.contains() is very, very, very good performance\n    // http://jsperf.com/closest-vs-contains/5\n    const inBody = (element) => {\n        // Technically this is only required on IE, where contains() returns false for text nodes.\n        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).\n        const dom = isText(element) ? element.dom.parentNode : element.dom;\n        // use ownerDocument.body to ensure this works inside iframes.\n        // Normally contains is bad because an element \"contains\" itself, but here we want that.\n        if (dom === undefined || dom === null || dom.ownerDocument === null) {\n            return false;\n        }\n        const doc = dom.ownerDocument;\n        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    const internalSet = (dom, property, value) => {\n        // This is going to hurt. Apologies.\n        // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.\n        // we're going to be explicit; strings only.\n        if (!isString(value)) {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n            throw new Error('CSS value must be a string: ' + value);\n        }\n        // removed: support for dom().style[property] where prop is camel case instead of normal property name\n        if (isSupported(dom)) {\n            dom.style.setProperty(property, value);\n        }\n    };\n    const internalRemove = (dom, property) => {\n        /*\n         * IE9 and above - MDN doesn't have details, but here's a couple of random internet claims\n         *\n         * http://help.dottoro.com/ljopsjck.php\n         * http://stackoverflow.com/a/7901886/7546\n         */\n        if (isSupported(dom)) {\n            dom.style.removeProperty(property);\n        }\n    };\n    const set$1 = (element, property, value) => {\n        const dom = element.dom;\n        internalSet(dom, property, value);\n    };\n    /*\n     * NOTE: For certain properties, this returns the \"used value\" which is subtly different to the \"computed value\" (despite calling getComputedStyle).\n     * Blame CSS 2.0.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n     */\n    const get$1 = (element, property) => {\n        const dom = element.dom;\n        /*\n         * IE9 and above per\n         * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle\n         *\n         * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.\n         *\n         * JQuery has some magic here for IE popups, but we don't really need that.\n         * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.\n         */\n        const styles = window.getComputedStyle(dom);\n        const r = styles.getPropertyValue(property);\n        // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.\n        // Turns out we do this a lot.\n        return (r === '' && !inBody(element)) ? getUnsafeProperty(dom, property) : r;\n    };\n    // removed: support for dom().style[property] where prop is camel case instead of normal property name\n    // empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    /*\n     * Gets the raw value from the style attribute. Useful for retrieving \"used values\" from the DOM:\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n     *\n     * Returns NONE if the property isn't set, or the value is an empty string.\n     */\n    const getRaw$1 = (element, property) => {\n        const dom = element.dom;\n        const raw = getUnsafeProperty(dom, property);\n        return Optional.from(raw).filter((r) => r.length > 0);\n    };\n    const remove = (element, property) => {\n        const dom = element.dom;\n        internalRemove(dom, property);\n        if (is$2(getOpt(element, 'style').map(trim), '')) {\n            // No more styles left, remove the style attribute as well\n            remove$2(element, 'style');\n        }\n    };\n\n    const Dimension = (name, getOffset) => {\n        const set = (element, h) => {\n            if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n                throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n            }\n            const dom = element.dom;\n            if (isSupported(dom)) {\n                dom.style[name] = h + 'px';\n            }\n        };\n        /*\n         * jQuery supports querying width and height on the document and window objects.\n         *\n         * TBIO doesn't do this, so the code is removed to save space, but left here just in case.\n         */\n        /*\n        var getDocumentWidth = (element) => {\n          var dom = element.dom;\n          if (Node.isDocument(element)) {\n            var body = dom.body;\n            var doc = dom.documentElement;\n            return Math.max(\n              body.scrollHeight,\n              doc.scrollHeight,\n              body.offsetHeight,\n              doc.offsetHeight,\n              doc.clientHeight\n            );\n          }\n        };\n      \n        var getWindowWidth = (element) => {\n          var dom = element.dom;\n          if (dom.window === dom) {\n            // There is no offsetHeight on a window, so use the clientHeight of the document\n            return dom.document.documentElement.clientHeight;\n          }\n        };\n      */\n        const get = (element) => {\n            const r = getOffset(element);\n            // zero or null means non-standard or disconnected, fall back to CSS\n            if (r <= 0 || r === null) {\n                const css = get$1(element, name);\n                // ugh this feels dirty, but it saves cycles\n                return parseFloat(css) || 0;\n            }\n            return r;\n        };\n        // in jQuery, getOuter replicates (or uses) box-sizing: border-box calculations\n        // although these calculations only seem relevant for quirks mode, and edge cases TBIO doesn't rely on\n        const getOuter = get;\n        const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n            const val = get$1(element, property);\n            const value = val === undefined ? 0 : parseInt(val, 10);\n            return isNaN(value) ? acc : acc + value;\n        }, 0);\n        const max = (element, value, properties) => {\n            const cumulativeInclusions = aggregate(element, properties);\n            // if max-height is 100px and your cumulativeInclusions is 150px, there is no way max-height can be 100px, so we return 0.\n            const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n            return absoluteMax;\n        };\n        return {\n            set,\n            get,\n            getOuter,\n            aggregate,\n            max\n        };\n    };\n\n    const toNumber = (px, fallback) => toFloat(px).getOr(fallback);\n    const getProp = (element, name, fallback) => toNumber(get$1(element, name), fallback);\n    const calcContentBoxSize = (element, size, upper, lower) => {\n        const paddingUpper = getProp(element, `padding-${upper}`, 0);\n        const paddingLower = getProp(element, `padding-${lower}`, 0);\n        const borderUpper = getProp(element, `border-${upper}-width`, 0);\n        const borderLower = getProp(element, `border-${lower}-width`, 0);\n        return size - paddingUpper - paddingLower - borderUpper - borderLower;\n    };\n    const getCalculatedWidth = (element, boxSizing) => {\n        const dom = element.dom;\n        const width = dom.getBoundingClientRect().width || dom.offsetWidth;\n        return boxSizing === 'border-box' ? width : calcContentBoxSize(element, width, 'left', 'right');\n    };\n    const getInnerWidth = (element) => getCalculatedWidth(element, 'content-box');\n\n    Dimension('width', (element) => \n    // IMO passing this function is better than using dom['offset' + 'width']\n    element.dom.offsetWidth);\n    Dimension('width', (element) => {\n        const dom = element.dom;\n        return inBody(element) ? dom.getBoundingClientRect().width : dom.offsetWidth;\n    });\n    const getInner = getInnerWidth;\n\n    const NodeValue = (is, name) => {\n        const get = (element) => {\n            if (!is(element)) {\n                throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n            }\n            return getOption(element).getOr('');\n        };\n        const getOption = (element) => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n        const set = (element, value) => {\n            if (!is(element)) {\n                throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n            }\n            element.dom.nodeValue = value;\n        };\n        return {\n            get,\n            getOption,\n            set\n        };\n    };\n\n    const api = NodeValue(isText, 'text');\n    const get = (element) => api.get(element);\n    const set = (element, value) => api.set(element, value);\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n        if (is(scope, a)) {\n            return Optional.some(scope);\n        }\n        else if (isFunction(isRoot) && isRoot(scope)) {\n            return Optional.none();\n        }\n        else {\n            return ancestor(scope, a, isRoot);\n        }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => {\n        let element = scope.dom;\n        const stop = isFunction(isRoot) ? isRoot : never;\n        while (element.parentNode) {\n            element = element.parentNode;\n            const el = SugarElement.fromDom(element);\n            if (predicate(el)) {\n                return Optional.some(el);\n            }\n            else if (stop(el)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n        // This is required to avoid ClosestOrAncestor passing the predicate to itself\n        const is = (s, test) => test(s);\n        return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);\n    };\n    const child$2 = (scope, predicate) => {\n        const pred = (node) => predicate(SugarElement.fromDom(node));\n        const result = find(scope.dom.childNodes, pred);\n        return result.map(SugarElement.fromDom);\n    };\n\n    const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is$1(e, selector), isRoot);\n    const child$1 = (scope, selector) => child$2(scope, (e) => is$1(e, selector));\n    const descendant = (scope, selector) => one(selector, scope);\n    // Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise\n    const closest$1 = (scope, selector, isRoot) => {\n        const is = (element, selector) => is$1(element, selector);\n        return ClosestOrAncestor(is, ancestor, scope, selector, isRoot);\n    };\n\n    const closest = (target) => closest$1(target, '[contenteditable]');\n    const isEditable = (element, assumeEditable = false) => {\n        if (inBody(element)) {\n            return element.dom.isContentEditable;\n        }\n        else {\n            // Find the closest contenteditable element and check if it's editable\n            return closest(element).fold(constant(assumeEditable), (editable) => getRaw(editable) === 'true');\n        }\n    };\n    const getRaw = (element) => element.dom.contentEditable;\n\n    const children$2 = (scope, predicate) => filter$1(children$3(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n        let result = [];\n        // Recurse.toArray() might help here\n        each$1(children$3(scope), (x) => {\n            if (predicate(x)) {\n                result = result.concat([x]);\n            }\n            result = result.concat(descendants$1(x, predicate));\n        });\n        return result;\n    };\n\n    const children$1 = (scope, selector) => \n    // It may surprise you to learn this is exactly what JQuery does\n    // TODO: Avoid all the wrapping and unwrapping\n    children$2(scope, (e) => is$1(e, selector));\n    const descendants = (scope, selector) => all$1(selector, scope);\n\n    const child = (scope, selector) => child$1(scope, selector).isSome();\n\n    /*\n     NOTE: This file is partially duplicated in the following locations:\n      - models/dom/table/core/TableUtils.ts\n      - advtable\n     Make sure that if making changes to this file, the other files are updated as well\n     */\n    const getNodeName = (elm) => elm.nodeName.toLowerCase();\n    const getBody = (editor) => SugarElement.fromDom(editor.getBody());\n    const getIsRoot = (editor) => (element) => eq(element, getBody(editor));\n    const removePxSuffix = (size) => size ? size.replace(/px$/, '') : '';\n    const addPxSuffix = (size) => /^\\d+(\\.\\d+)?$/.test(size) ? size + 'px' : size;\n    const getSelectionStart = (editor) => SugarElement.fromDom(editor.selection.getStart());\n    const getSelectionEnd = (editor) => SugarElement.fromDom(editor.selection.getEnd());\n    const isInEditableContext = (cell) => closest$2(cell, isTag('table')).forall(isEditable);\n\n    const validSectionList = ['tfoot', 'thead', 'tbody', 'colgroup'];\n    const isValidSection = (parentName) => contains(validSectionList, parentName);\n    const grid = (rows, columns) => ({\n        rows,\n        columns\n    });\n    const detail = (element, rowspan, colspan) => ({\n        element,\n        rowspan,\n        colspan\n    });\n    const extended = (element, rowspan, colspan, row, column, isLocked) => ({\n        element,\n        rowspan,\n        colspan,\n        row,\n        column,\n        isLocked\n    });\n    const rowdetail = (element, cells, section) => ({\n        element,\n        cells,\n        section\n    });\n    const bounds = (startRow, startCol, finishRow, finishCol) => ({\n        startRow,\n        startCol,\n        finishRow,\n        finishCol\n    });\n    const columnext = (element, colspan, column) => ({\n        element,\n        colspan,\n        column\n    });\n    const colgroup = (element, columns) => ({\n        element,\n        columns\n    });\n\n    const getAttrValue = (cell, name, fallback = 0) => getOpt(cell, name).map((value) => parseInt(value, 10)).getOr(fallback);\n\n    const firstLayer = (scope, selector) => {\n        return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n        return bind(children$3(scope), (x) => {\n            if (is$1(x, selector)) {\n                return predicate(x) ? [x] : [];\n            }\n            else {\n                return filterFirstLayer(x, selector, predicate);\n            }\n        });\n    };\n\n    // lookup inside this table\n    const lookup = (tags, element, isRoot = never) => {\n        // If the element we're inspecting is the root, we definitely don't want it.\n        if (isRoot(element)) {\n            return Optional.none();\n        }\n        // This looks a lot like SelectorFind.closest, with one big exception - the isRoot check.\n        // The code here will look for parents if passed a table, SelectorFind.closest with that specific isRoot check won't.\n        if (contains(tags, name(element))) {\n            return Optional.some(element);\n        }\n        const isRootOrUpperTable = (elm) => is$1(elm, 'table') || isRoot(elm);\n        return ancestor(element, tags.join(','), isRootOrUpperTable);\n    };\n    /*\n     * Identify the optional cell that element represents.\n     */\n    const cell = (element, isRoot) => lookup(['td', 'th'], element, isRoot);\n    const cells = (ancestor) => firstLayer(ancestor, 'th,td');\n    const columns = (ancestor) => {\n        if (is$1(ancestor, 'colgroup')) {\n            return children$1(ancestor, 'col');\n        }\n        else {\n            return bind(columnGroups(ancestor), (columnGroup) => children$1(columnGroup, 'col'));\n        }\n    };\n    const table = (element, isRoot) => closest$1(element, 'table', isRoot);\n    const rows = (ancestor) => firstLayer(ancestor, 'tr');\n    const columnGroups = (ancestor) => table(ancestor).fold(constant([]), (table) => children$1(table, 'colgroup'));\n\n    const isHeaderCell = isTag('th');\n    const getRowHeaderType = (isHeaderRow, isHeaderCells) => {\n        if (isHeaderRow && isHeaderCells) {\n            return 'sectionCells';\n        }\n        else if (isHeaderRow) {\n            return 'section';\n        }\n        else {\n            return 'cells';\n        }\n    };\n    const getRowType$1 = (row) => {\n        // Header rows can use a combination of theads and ths - want to detect the different combinations\n        const isHeaderRow = row.section === 'thead';\n        const isHeaderCells = is$2(findCommonCellType(row.cells), 'th');\n        if (row.section === 'tfoot') {\n            return { type: 'footer' };\n        }\n        else if (isHeaderRow || isHeaderCells) {\n            return { type: 'header', subType: getRowHeaderType(isHeaderRow, isHeaderCells) };\n        }\n        else {\n            return { type: 'body' };\n        }\n    };\n    const findCommonCellType = (cells) => {\n        const headerCells = filter$1(cells, (cell) => isHeaderCell(cell.element));\n        if (headerCells.length === 0) {\n            return Optional.some('td');\n        }\n        else if (headerCells.length === cells.length) {\n            return Optional.some('th');\n        }\n        else {\n            return Optional.none();\n        }\n    };\n    const findCommonRowType = (rows) => {\n        const rowTypes = map(rows, (row) => getRowType$1(row).type);\n        const hasHeader = contains(rowTypes, 'header');\n        const hasFooter = contains(rowTypes, 'footer');\n        if (!hasHeader && !hasFooter) {\n            return Optional.some('body');\n        }\n        else {\n            const hasBody = contains(rowTypes, 'body');\n            if (hasHeader && !hasBody && !hasFooter) {\n                return Optional.some('header');\n            }\n            else if (!hasHeader && !hasBody && hasFooter) {\n                return Optional.some('footer');\n            }\n            else {\n                return Optional.none();\n            }\n        }\n    };\n\n    const fromRowsOrColGroups = (elems, getSection) => map(elems, (row) => {\n        if (name(row) === 'colgroup') {\n            const cells = map(columns(row), (column) => {\n                const colspan = getAttrValue(column, 'span', 1);\n                return detail(column, 1, colspan);\n            });\n            return rowdetail(row, cells, 'colgroup');\n        }\n        else {\n            const cells$1 = map(cells(row), (cell) => {\n                const rowspan = getAttrValue(cell, 'rowspan', 1);\n                const colspan = getAttrValue(cell, 'colspan', 1);\n                return detail(cell, rowspan, colspan);\n            });\n            return rowdetail(row, cells$1, getSection(row));\n        }\n    });\n    const getParentSection = (group) => parent(group).map((parent) => {\n        const parentName = name(parent);\n        return isValidSection(parentName) ? parentName : 'tbody';\n    }).getOr('tbody');\n    /*\n     * Takes a DOM table and returns a list of list of:\n       element: row element\n       cells: (id, rowspan, colspan) structs\n     */\n    const fromTable$1 = (table) => {\n        const rows$1 = rows(table);\n        const columnGroups$1 = columnGroups(table);\n        const elems = [...columnGroups$1, ...rows$1];\n        return fromRowsOrColGroups(elems, getParentSection);\n    };\n\n    const LOCKED_COL_ATTR = 'data-snooker-locked-cols';\n    const getLockedColumnsFromTable = (table) => getOpt(table, LOCKED_COL_ATTR)\n        .bind((lockedColStr) => Optional.from(lockedColStr.match(/\\d+/g)))\n        .map((lockedCols) => mapToObject(lockedCols, always));\n\n    const key = (row, column) => {\n        return row + ',' + column;\n    };\n    const getAt = (warehouse, row, column) => Optional.from(warehouse.access[key(row, column)]);\n    const findItem = (warehouse, item, comparator) => {\n        const filtered = filterItems(warehouse, (detail) => {\n            return comparator(item, detail.element);\n        });\n        return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();\n    };\n    const filterItems = (warehouse, predicate) => {\n        const all = bind(warehouse.all, (r) => {\n            return r.cells;\n        });\n        return filter$1(all, predicate);\n    };\n    const generateColumns = (rowData) => {\n        const columnsGroup = {};\n        let index = 0;\n        each$1(rowData.cells, (column) => {\n            const colspan = column.colspan;\n            range(colspan, (columnIndex) => {\n                const colIndex = index + columnIndex;\n                columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);\n            });\n            index += colspan;\n        });\n        return columnsGroup;\n    };\n    /*\n     * From a list of list of Detail, generate three pieces of information:\n     *  1. the grid size\n     *  2. a data structure which can efficiently identify which cell is in which row,column position\n     *  3. a list of all cells in order left-to-right, top-to-bottom\n     */\n    const generate = (list) => {\n        // list is an array of objects, made by cells and elements\n        // elements: is the TR\n        // cells: is an array of objects representing the cells in the row.\n        //        It is made of:\n        //          colspan (merge cell)\n        //          element\n        //          rowspan (merge cols)\n        const access = {};\n        const cells = [];\n        const tableOpt = head(list).map((rowData) => rowData.element).bind(table);\n        const lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});\n        let maxRows = 0;\n        let maxColumns = 0;\n        let rowCount = 0;\n        const { pass: colgroupRows, fail: rows } = partition(list, (rowData) => rowData.section === 'colgroup');\n        // Handle rows first\n        each$1(rows, (rowData) => {\n            const currentRow = [];\n            each$1(rowData.cells, (rowCell) => {\n                let start = 0;\n                // If this spot has been taken by a previous rowspan, skip it.\n                while (access[key(rowCount, start)] !== undefined) {\n                    start++;\n                }\n                const isLocked = hasNonNullableKey(lockedColumns, start.toString());\n                const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);\n                // Occupy all the (row, column) positions that this cell spans for.\n                for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) {\n                    for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {\n                        const rowPosition = rowCount + occupiedRowPosition;\n                        const columnPosition = start + occupiedColumnPosition;\n                        const newpos = key(rowPosition, columnPosition);\n                        access[newpos] = current;\n                        maxColumns = Math.max(maxColumns, columnPosition + 1);\n                    }\n                }\n                currentRow.push(current);\n            });\n            maxRows++;\n            cells.push(rowdetail(rowData.element, currentRow, rowData.section));\n            rowCount++;\n        });\n        // Handle colgroups\n        // Note: Currently only a single colgroup is supported so just use the last one\n        const { columns, colgroups } = last(colgroupRows).map((rowData) => {\n            const columns = generateColumns(rowData);\n            const colgroup$1 = colgroup(rowData.element, values(columns));\n            return {\n                colgroups: [colgroup$1],\n                columns\n            };\n        }).getOrThunk(() => ({\n            colgroups: [],\n            columns: {}\n        }));\n        const grid$1 = grid(maxRows, maxColumns);\n        return {\n            grid: grid$1,\n            access,\n            all: cells,\n            columns,\n            colgroups\n        };\n    };\n    const fromTable = (table) => {\n        const list = fromTable$1(table);\n        return generate(list);\n    };\n    const justCells = (warehouse) => bind(warehouse.all, (w) => w.cells);\n    const justColumns = (warehouse) => values(warehouse.columns);\n    const hasColumns = (warehouse) => keys(warehouse.columns).length > 0;\n    const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);\n    const Warehouse = {\n        fromTable,\n        generate,\n        getAt,\n        findItem,\n        filterItems,\n        justCells,\n        justColumns,\n        hasColumns,\n        getColumnAt\n    };\n\n    const findInWarehouse = (warehouse, element) => findMap(warehouse.all, (r) => find(r.cells, (e) => eq(element, e.element)));\n    const extractCells = (warehouse, target, predicate) => {\n        const details = map(target.selection, (cell$1) => {\n            return cell(cell$1)\n                .bind((lc) => findInWarehouse(warehouse, lc))\n                .filter(predicate);\n        });\n        const cells = cat(details);\n        return someIf(cells.length > 0, cells);\n    };\n    const onMergable = (_warehouse, target) => target.mergable;\n    const onUnmergable = (_warehouse, target) => target.unmergable;\n    const onCells = (warehouse, target) => extractCells(warehouse, target, always);\n    const isUnlockedTableCell = (warehouse, cell) => findInWarehouse(warehouse, cell).exists((detail) => !detail.isLocked);\n    const allUnlocked = (warehouse, cells) => forall(cells, (cell) => isUnlockedTableCell(warehouse, cell));\n    // If any locked columns are present in the selection, then don't want to be able to merge\n    const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter((mergeable) => allUnlocked(warehouse, mergeable.cells));\n    // If any locked columns are present in the selection, then don't want to be able to unmerge\n    const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter((cells) => allUnlocked(warehouse, cells));\n\n    const isCol = isTag('col');\n    const isColgroup = isTag('colgroup');\n    const isRow = (element) => name(element) === 'tr' || isColgroup(element);\n    const elementToData = (element) => {\n        const colspan = getAttrValue(element, 'colspan', 1);\n        const rowspan = getAttrValue(element, 'rowspan', 1);\n        return {\n            element,\n            colspan,\n            rowspan\n        };\n    };\n    // note that `toData` seems to be only for testing\n    const modification = (generators, toData = elementToData) => {\n        const nuCell = (data) => isCol(data.element) ? generators.col(data) : generators.cell(data);\n        const nuRow = (data) => isColgroup(data.element) ? generators.colgroup(data) : generators.row(data);\n        const add = (element) => {\n            if (isRow(element)) {\n                return nuRow({ element });\n            }\n            else {\n                const cell = element;\n                const replacement = nuCell(toData(cell));\n                recent = Optional.some({ item: cell, replacement });\n                return replacement;\n            }\n        };\n        let recent = Optional.none();\n        const getOrInit = (element, comparator) => {\n            return recent.fold(() => {\n                return add(element);\n            }, (p) => {\n                return comparator(element, p.item) ? p.replacement : add(element);\n            });\n        };\n        return {\n            getOrInit\n        };\n    };\n    const transform = (tag) => {\n        return (generators) => {\n            const list = [];\n            const find$1 = (element, comparator) => {\n                return find(list, (x) => {\n                    return comparator(x.item, element);\n                });\n            };\n            const makeNew = (element) => {\n                // Ensure scope is never set on a td element as it's a deprecated attribute\n                const attrs = tag === 'td' ? { scope: null } : {};\n                const cell = generators.replace(element, tag, attrs);\n                list.push({\n                    item: element,\n                    sub: cell\n                });\n                return cell;\n            };\n            const replaceOrInit = (element, comparator) => {\n                if (isRow(element) || isCol(element)) {\n                    return element;\n                }\n                else {\n                    const cell = element;\n                    return find$1(cell, comparator).fold(() => {\n                        return makeNew(cell);\n                    }, (p) => {\n                        return comparator(element, p.item) ? p.sub : makeNew(cell);\n                    });\n                }\n            };\n            return {\n                replaceOrInit\n            };\n        };\n    };\n    const getScopeAttribute = (cell) => getOpt(cell, 'scope').map(\n    // Attribute can be col, colgroup, row, and rowgroup.\n    // As col and colgroup are to be treated as if they are the same, lob off everything after the first three characters and there is no difference.\n    (attribute) => attribute.substr(0, 3));\n    const merging = (generators) => {\n        const unmerge = (cell) => {\n            const scope = getScopeAttribute(cell);\n            scope.each((attribute) => set$2(cell, 'scope', attribute));\n            return () => {\n                const raw = generators.cell({\n                    element: cell,\n                    colspan: 1,\n                    rowspan: 1\n                });\n                // Remove any width calculations because they are no longer relevant.\n                remove(raw, 'width');\n                remove(cell, 'width');\n                scope.each((attribute) => set$2(raw, 'scope', attribute));\n                return raw;\n            };\n        };\n        const merge = (cells) => {\n            const getScopeProperty = () => {\n                const stringAttributes = cat(map(cells, getScopeAttribute));\n                if (stringAttributes.length === 0) {\n                    return Optional.none();\n                }\n                else {\n                    const baseScope = stringAttributes[0];\n                    const scopes = ['row', 'col'];\n                    const isMixed = exists(stringAttributes, (attribute) => {\n                        return attribute !== baseScope && contains(scopes, attribute);\n                    });\n                    return isMixed ? Optional.none() : Optional.from(baseScope);\n                }\n            };\n            remove(cells[0], 'width');\n            getScopeProperty().fold(() => remove$2(cells[0], 'scope'), (attribute) => set$2(cells[0], 'scope', attribute + 'group'));\n            return constant(cells[0]);\n        };\n        return {\n            unmerge,\n            merge\n        };\n    };\n    const Generators = {\n        modification,\n        transform,\n        merging\n    };\n\n    var TagBoundaries = [\n        'body',\n        'p',\n        'div',\n        'article',\n        'aside',\n        'figcaption',\n        'figure',\n        'footer',\n        'header',\n        'nav',\n        'section',\n        'ol',\n        'ul',\n        'li',\n        'table',\n        'thead',\n        'tbody',\n        'tfoot',\n        'caption',\n        'tr',\n        'td',\n        'th',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'blockquote',\n        'pre',\n        'address'\n    ];\n\n    var DomUniverse = () => {\n        const clone$1 = (element) => {\n            return SugarElement.fromDom(element.dom.cloneNode(false));\n        };\n        const document = (element) => documentOrOwner(element).dom;\n        const isBoundary = (element) => {\n            if (!isElement(element)) {\n                return false;\n            }\n            if (name(element) === 'body') {\n                return true;\n            }\n            return contains(TagBoundaries, name(element));\n        };\n        const isEmptyTag = (element) => {\n            if (!isElement(element)) {\n                return false;\n            }\n            return contains(['br', 'img', 'hr', 'input'], name(element));\n        };\n        const isNonEditable = (element) => isElement(element) && get$2(element, 'contenteditable') === 'false';\n        const comparePosition = (element, other) => {\n            return element.dom.compareDocumentPosition(other.dom);\n        };\n        const copyAttributesTo = (source, destination) => {\n            const as = clone(source);\n            setAll(destination, as);\n        };\n        const isSpecial = (element) => {\n            const tag = name(element);\n            return contains([\n                'script', 'noscript', 'iframe', 'noframes', 'noembed', 'title', 'style', 'textarea', 'xmp'\n            ], tag);\n        };\n        const getLanguage = (element) => isElement(element) ? getOpt(element, 'lang') : Optional.none();\n        return {\n            up: constant({\n                selector: ancestor,\n                closest: closest$1,\n                predicate: ancestor$1,\n                all: parents\n            }),\n            down: constant({\n                selector: descendants,\n                predicate: descendants$1\n            }),\n            styles: constant({\n                get: get$1,\n                getRaw: getRaw$1,\n                set: set$1,\n                remove: remove\n            }),\n            attrs: constant({\n                get: get$2,\n                set: set$2,\n                remove: remove$2,\n                copyTo: copyAttributesTo\n            }),\n            insert: constant({\n                before: before,\n                after: after$1,\n                afterAll: after,\n                append: append$1,\n                appendAll: append,\n                prepend: prepend,\n                wrap: wrap\n            }),\n            remove: constant({\n                unwrap: unwrap,\n                remove: remove$1\n            }),\n            create: constant({\n                nu: SugarElement.fromTag,\n                clone: clone$1,\n                text: SugarElement.fromText\n            }),\n            query: constant({\n                comparePosition,\n                prevSibling: prevSibling,\n                nextSibling: nextSibling\n            }),\n            property: constant({\n                children: children$3,\n                name: name,\n                parent: parent,\n                document,\n                isText: isText,\n                isComment: isComment,\n                isElement: isElement,\n                isSpecial,\n                getLanguage,\n                getText: get,\n                setText: set,\n                isBoundary,\n                isEmptyTag,\n                isNonEditable\n            }),\n            eq: eq,\n            is: is\n        };\n    };\n\n    const leftRight = (left, right) => ({\n        left,\n        right\n    });\n    const brokenPath = (first, second, splits) => ({\n        first,\n        second,\n        splits\n    });\n    const bisect = (universe, parent, child) => {\n        const children = universe.property().children(parent);\n        const index = findIndex(children, curry(universe.eq, child));\n        return index.map((ind) => {\n            return {\n                before: children.slice(0, ind),\n                after: children.slice(ind + 1)\n            };\n        });\n    };\n    /**\n     * Clone parent to the RIGHT and move everything after child in the parent element into\n     * a clone of the parent (placed after parent).\n     */\n    const breakToRight = (universe, parent, child) => {\n        return bisect(universe, parent, child).map((parts) => {\n            const second = universe.create().clone(parent);\n            universe.insert().appendAll(second, parts.after);\n            universe.insert().after(parent, second);\n            return leftRight(parent, second);\n        });\n    };\n    /**\n     * Clone parent to the LEFT and move everything before and including child into\n     * the a clone of the parent (placed before parent)\n     */\n    const breakToLeft = (universe, parent, child) => {\n        return bisect(universe, parent, child).map((parts) => {\n            const prior = universe.create().clone(parent);\n            universe.insert().appendAll(prior, parts.before.concat([child]));\n            universe.insert().appendAll(parent, parts.after);\n            universe.insert().before(parent, prior);\n            return leftRight(prior, parent);\n        });\n    };\n    /*\n     * Using the breaker, break from the child up to the top element defined by the predicate.\n     * It returns three values:\n     *   first: the top level element that completed the break\n     *   second: the optional element representing second part of the top-level split if the breaking completed successfully to the top\n     *   splits: a list of (Element, Element) pairs that represent the splits that have occurred on the way to the top.\n     */\n    const breakPath = (universe, item, isTop, breaker) => {\n        const next = (child, group, splits) => {\n            const fallback = brokenPath(child, Optional.none(), splits);\n            // Found the top, so stop.\n            if (isTop(child)) {\n                return brokenPath(child, group, splits);\n            }\n            else {\n                // Split the child at parent, and keep going\n                return universe.property().parent(child).bind((parent) => {\n                    return breaker(universe, parent, child).map((breakage) => {\n                        const extra = [{ first: breakage.left, second: breakage.right }];\n                        // Our isTop is based on the left-side parent, so keep it regardless of split.\n                        const nextChild = isTop(parent) ? parent : breakage.left;\n                        return next(nextChild, Optional.some(breakage.right), splits.concat(extra));\n                    });\n                }).getOr(fallback);\n            }\n        };\n        return next(item, Optional.none(), []);\n    };\n\n    const all = (universe, look, elements, f) => {\n        const head = elements[0];\n        const tail = elements.slice(1);\n        return f(universe, look, head, tail);\n    };\n    /**\n     * Check if look returns the same element for all elements, and return it if it exists.\n     */\n    const oneAll = (universe, look, elements) => {\n        return elements.length > 0 ?\n            all(universe, look, elements, unsafeOne) :\n            Optional.none();\n    };\n    const unsafeOne = (universe, look, head, tail) => {\n        const start = look(universe, head);\n        return foldr(tail, (b, a) => {\n            const current = look(universe, a);\n            return commonElement(universe, b, current);\n        }, start);\n    };\n    const commonElement = (universe, start, end) => {\n        return start.bind((s) => {\n            return end.filter(curry(universe.eq, s));\n        });\n    };\n\n    const sharedOne$1 = oneAll;\n    breakToLeft;\n    breakToRight;\n    breakPath;\n\n    const universe = DomUniverse();\n    const sharedOne = (look, elements) => {\n        return sharedOne$1(universe, (_universe, element) => {\n            return look(element);\n        }, elements);\n    };\n\n    const opGetRowsType = (table, target) => {\n        const house = Warehouse.fromTable(table);\n        const details = onCells(house, target);\n        return details.bind((selectedCells) => {\n            const lastSelectedCell = selectedCells[selectedCells.length - 1];\n            const minRowRange = selectedCells[0].row;\n            const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;\n            const selectedRows = house.all.slice(minRowRange, maxRowRange);\n            return findCommonRowType(selectedRows);\n        }).getOr('');\n    };\n    Generators.transform('th');\n    Generators.transform('td');\n    const getRowsType = opGetRowsType;\n\n    // Note, something is *within* if it is completely contained within the bounds.\n    const isWithin = (bounds, detail) => {\n        return (detail.column >= bounds.startCol &&\n            (detail.column + detail.colspan - 1) <= bounds.finishCol &&\n            detail.row >= bounds.startRow &&\n            (detail.row + detail.rowspan - 1) <= bounds.finishRow);\n    };\n    const isRectangular = (warehouse, bounds) => {\n        let isRect = true;\n        const detailIsWithin = curry(isWithin, bounds);\n        for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n            for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n                isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);\n            }\n        }\n        return isRect ? Optional.some(bounds) : Optional.none();\n    };\n\n    const getBounds = (detailA, detailB) => {\n        return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));\n    };\n    const getAnyBox = (warehouse, startCell, finishCell) => {\n        const startCoords = Warehouse.findItem(warehouse, startCell, eq);\n        const finishCoords = Warehouse.findItem(warehouse, finishCell, eq);\n        return startCoords.bind((sc) => {\n            return finishCoords.map((fc) => {\n                return getBounds(sc, fc);\n            });\n        });\n    };\n    const getBox$1 = (warehouse, startCell, finishCell) => {\n        return getAnyBox(warehouse, startCell, finishCell).bind((bounds) => {\n            return isRectangular(warehouse, bounds);\n        });\n    };\n\n    const getBox = (table, first, last) => {\n        const warehouse = getWarehouse(table);\n        return getBox$1(warehouse, first, last);\n    };\n    // Private method ... keep warehouse in snooker, please.\n    const getWarehouse = Warehouse.fromTable;\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const getTDTHOverallStyle = (dom, elm, name) => {\n        const cells = dom.select('td,th', elm);\n        let firstChildStyle;\n        for (let i = 0; i < cells.length; i++) {\n            const currentStyle = dom.getStyle(cells[i], name);\n            if (isUndefined(firstChildStyle)) {\n                firstChildStyle = currentStyle;\n            }\n            if (firstChildStyle !== currentStyle) {\n                return '';\n            }\n        }\n        return firstChildStyle;\n    };\n    const setAlign = (editor, elm, name) => {\n        // Alignment formats may not use the same styles so ensure to remove any existing horizontal alignment format first\n        global$2.each('left center right'.split(' '), (align) => {\n            if (align !== name) {\n                editor.formatter.remove('align' + align, {}, elm);\n            }\n        });\n        if (name) {\n            editor.formatter.apply('align' + name, {}, elm);\n        }\n    };\n    const setVAlign = (editor, elm, name) => {\n        // Alignment formats may not use the same styles so ensure to remove any existing vertical alignment format first\n        global$2.each('top middle bottom'.split(' '), (align) => {\n            if (align !== name) {\n                editor.formatter.remove('valign' + align, {}, elm);\n            }\n        });\n        if (name) {\n            editor.formatter.apply('valign' + name, {}, elm);\n        }\n    };\n\n    /*\n     NOTE: This file is duplicated in the following locations:\n      - core/api/TableEvents.ts\n      - models/dom/table/api/Events.ts\n      - advtable\n     Make sure that if making changes to this file, the other files are updated as well\n     */\n    const fireTableModified = (editor, table, data) => {\n        editor.dispatch('TableModified', { ...data, table });\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.Env');\n\n    const defaultTableToolbar = 'tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol';\n    const defaultCellBorderWidths = range(5, (i) => {\n        const size = `${i + 1}px`;\n        return { title: size, value: size };\n    });\n    const defaultCellBorderStyles = map(['Solid', 'Dotted', 'Dashed', 'Double', 'Groove', 'Ridge', 'Inset', 'Outset', 'None', 'Hidden'], (type) => {\n        return { title: type, value: type.toLowerCase() };\n    });\n    // Note: This is also contained in the core Options.ts file\n    const defaultWidth = '100%';\n    const getPixelForcedWidth = (editor) => {\n        var _a;\n        // Determine the inner size of the parent block element where the table will be inserted\n        const dom = editor.dom;\n        const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();\n        return getInner(SugarElement.fromDom(parentBlock)) + 'px';\n    };\n    // Note: This is also contained in the core Options.ts file\n    const determineDefaultStyles = (editor, defaultStyles) => {\n        if (isResponsiveForced(editor) || !shouldStyleWithCss(editor)) {\n            return defaultStyles;\n        }\n        else if (isPixelsForced(editor)) {\n            return { ...defaultStyles, width: getPixelForcedWidth(editor) };\n        }\n        else {\n            return { ...defaultStyles, width: defaultWidth };\n        }\n    };\n    // Note: This is also contained in the core Options.ts file\n    const determineDefaultAttributes = (editor, defaultAttributes) => {\n        if (isResponsiveForced(editor) || shouldStyleWithCss(editor)) {\n            return defaultAttributes;\n        }\n        else if (isPixelsForced(editor)) {\n            return { ...defaultAttributes, width: getPixelForcedWidth(editor) };\n        }\n        else {\n            return { ...defaultAttributes, width: defaultWidth };\n        }\n    };\n    const option = (name) => (editor) => editor.options.get(name);\n    const register = (editor) => {\n        const registerOption = editor.options.register;\n        registerOption('table_border_widths', {\n            processor: 'object[]',\n            default: defaultCellBorderWidths\n        });\n        registerOption('table_border_styles', {\n            processor: 'object[]',\n            default: defaultCellBorderStyles\n        });\n        registerOption('table_cell_advtab', {\n            processor: 'boolean',\n            default: true\n        });\n        registerOption('table_row_advtab', {\n            processor: 'boolean',\n            default: true\n        });\n        registerOption('table_advtab', {\n            processor: 'boolean',\n            default: true\n        });\n        registerOption('table_appearance_options', {\n            processor: 'boolean',\n            default: true\n        });\n        registerOption('table_grid', {\n            processor: 'boolean',\n            // Table grid relies on hover, which isn't available on touch devices so use the dialog instead\n            default: !global$1.deviceType.isTouch()\n        });\n        registerOption('table_cell_class_list', {\n            processor: 'object[]',\n            default: []\n        });\n        registerOption('table_row_class_list', {\n            processor: 'object[]',\n            default: []\n        });\n        registerOption('table_class_list', {\n            processor: 'object[]',\n            default: []\n        });\n        registerOption('table_toolbar', {\n            processor: 'string',\n            default: defaultTableToolbar\n        });\n        registerOption('table_background_color_map', {\n            processor: 'object[]',\n            default: []\n        });\n        registerOption('table_border_color_map', {\n            processor: 'object[]',\n            default: []\n        });\n    };\n    const getTableSizingMode = option('table_sizing_mode');\n    const getTableBorderWidths = option('table_border_widths');\n    const getTableBorderStyles = option('table_border_styles');\n    const hasAdvancedCellTab = option('table_cell_advtab');\n    const hasAdvancedRowTab = option('table_row_advtab');\n    const hasAdvancedTableTab = option('table_advtab');\n    const hasAppearanceOptions = option('table_appearance_options');\n    const hasTableGrid = option('table_grid');\n    const shouldStyleWithCss = option('table_style_by_css');\n    const getCellClassList = option('table_cell_class_list');\n    const getRowClassList = option('table_row_class_list');\n    const getTableClassList = option('table_class_list');\n    const getToolbar = option('table_toolbar');\n    const getTableBackgroundColorMap = option('table_background_color_map');\n    const getTableBorderColorMap = option('table_border_color_map');\n    const isPixelsForced = (editor) => getTableSizingMode(editor) === 'fixed';\n    const isResponsiveForced = (editor) => getTableSizingMode(editor) === 'responsive';\n    const getDefaultStyles = (editor) => {\n        // Note: The we don't rely on the default here as we need to dynamically lookup the widths based on the current editor state\n        const options = editor.options;\n        const defaultStyles = options.get('table_default_styles');\n        return options.isSet('table_default_styles') ? defaultStyles : determineDefaultStyles(editor, defaultStyles);\n    };\n    const getDefaultAttributes = (editor) => {\n        // Note: The we don't rely on the default here as we need to dynamically lookup the widths based on the current editor state\n        const options = editor.options;\n        const defaultAttributes = options.get('table_default_attributes');\n        return options.isSet('table_default_attributes') ? defaultAttributes : determineDefaultAttributes(editor, defaultAttributes);\n    };\n\n    const lookupTable = (container) => {\n        return ancestor(container, 'table');\n    };\n    const retrieve$1 = (container, selector) => {\n        const sels = descendants(container, selector);\n        return sels.length > 0 ? Optional.some(sels) : Optional.none();\n    };\n    const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {\n        return descendant(container, firstSelectedSelector).bind((first) => {\n            return descendant(container, lastSelectedSelector).bind((last) => {\n                return sharedOne(lookupTable, [first, last]).map((table) => {\n                    return {\n                        first,\n                        last,\n                        table\n                    };\n                });\n            });\n        });\n    };\n\n    // Explicitly calling CellSelection.retrieve so that we can see the API signature.\n    const retrieve = (container, selector) => {\n        return retrieve$1(container, selector);\n    };\n    const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {\n        return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind((edges) => {\n            const isRoot = (ancestor) => {\n                return eq(container, ancestor);\n            };\n            const sectionSelector = 'thead,tfoot,tbody,table';\n            const firstAncestor = ancestor(edges.first, sectionSelector, isRoot);\n            const lastAncestor = ancestor(edges.last, sectionSelector, isRoot);\n            return firstAncestor.bind((fA) => {\n                return lastAncestor.bind((lA) => {\n                    return eq(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();\n                });\n            });\n        });\n    };\n\n    const selection = identity;\n    const unmergable = (selectedCells) => {\n        const hasSpan = (elem, type) => getOpt(elem, type).exists((span) => parseInt(span, 10) > 1);\n        const hasRowOrColSpan = (elem) => hasSpan(elem, 'rowspan') || hasSpan(elem, 'colspan');\n        return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();\n    };\n    const mergable = (table, selectedCells, ephemera) => {\n        if (selectedCells.length <= 1) {\n            return Optional.none();\n        }\n        else {\n            return retrieveBox(table, ephemera.firstSelectedSelector, ephemera.lastSelectedSelector)\n                .map((bounds) => ({ bounds, cells: selectedCells }));\n        }\n    };\n\n    /*\n     NOTE: This file is duplicated in the following locations:\n      - models/dom/table/selection/Ephemera.ts\n      - advtable\n     Make sure that if making changes to this file, the other files are updated as well\n     */\n    const strSelected = 'data-mce-selected';\n    const strSelectedSelector = 'td[' + strSelected + '],th[' + strSelected + ']';\n    const strFirstSelected = 'data-mce-first-selected';\n    const strFirstSelectedSelector = 'td[' + strFirstSelected + '],th[' + strFirstSelected + ']';\n    const strLastSelected = 'data-mce-last-selected';\n    const strLastSelectedSelector = 'td[' + strLastSelected + '],th[' + strLastSelected + ']';\n    const ephemera = {\n        selected: strSelected,\n        selectedSelector: strSelectedSelector,\n        firstSelected: strFirstSelected,\n        firstSelectedSelector: strFirstSelectedSelector,\n        lastSelected: strLastSelected,\n        lastSelectedSelector: strLastSelectedSelector\n    };\n\n    /*\n     NOTE: This file is partially duplicated in the following locations:\n      - models/dom/table/selection/TableSelection.ts\n      - advtable\n     Make sure that if making changes to this file, the other files are updated as well\n     */\n    const getSelectionCellFallback = (element) => table(element).bind((table) => retrieve(table, ephemera.firstSelectedSelector)).fold(constant(element), (cells) => cells[0]);\n    const getSelectionFromSelector = (selector) => (initCell, isRoot) => {\n        const cellName = name(initCell);\n        const cell = cellName === 'col' || cellName === 'colgroup' ? getSelectionCellFallback(initCell) : initCell;\n        return closest$1(cell, selector, isRoot);\n    };\n    const getSelectionCellOrCaption = getSelectionFromSelector('th,td,caption');\n    const getSelectionCell = getSelectionFromSelector('th,td');\n    const getCellsFromSelection = (editor) => fromDom(editor.model.table.getSelectedCells());\n    const getRowsFromSelection = (selected, selector) => {\n        const cellOpt = getSelectionCell(selected);\n        const rowsOpt = cellOpt.bind((cell) => table(cell))\n            .map((table) => rows(table));\n        return lift2(cellOpt, rowsOpt, (cell, rows) => filter$1(rows, (row) => exists(fromDom(row.dom.cells), (rowCell) => get$2(rowCell, selector) === '1' || eq(rowCell, cell)))).getOr([]);\n    };\n\n    const verticalAlignValues = [\n        {\n            text: 'None',\n            value: ''\n        },\n        {\n            text: 'Top',\n            value: 'top'\n        },\n        {\n            text: 'Middle',\n            value: 'middle'\n        },\n        {\n            text: 'Bottom',\n            value: 'bottom'\n        }\n    ];\n\n    const hexColour = (value) => ({\n        value: normalizeHex(value)\n    });\n    const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    const longformRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n    const isHexString = (hex) => shorthandRegex.test(hex) || longformRegex.test(hex);\n    const normalizeHex = (hex) => removeLeading(hex, '#').toUpperCase();\n    const fromString$1 = (hex) => isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();\n    const toHex = (component) => {\n        const hex = component.toString(16);\n        return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = (rgbaColour) => {\n        const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n        return hexColour(value);\n    };\n\n    /* eslint-disable no-console */\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*\\)\\s*$/i;\n    // This regex will match rgba(0, 0, 0, 0.5) or rgba(0, 0, 0, 50%) , or without commas\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*((?:\\d?\\.\\d+|\\d+)%?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n        red,\n        green,\n        blue,\n        alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n        const r = parseInt(red, 10);\n        const g = parseInt(green, 10);\n        const b = parseInt(blue, 10);\n        const a = parseFloat(alpha);\n        return rgbaColour(r, g, b, a);\n    };\n    const fromString = (rgbaString) => {\n        const rgbMatch = rgbRegex.exec(rgbaString);\n        if (rgbMatch !== null) {\n            return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n        }\n        const rgbaMatch = rgbaRegex.exec(rgbaString);\n        if (rgbaMatch !== null) {\n            return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n        }\n        return Optional.none();\n    };\n\n    const anyToHex = (color) => fromString$1(color)\n        .orThunk(() => fromString(color).map(fromRgba))\n        .getOrThunk(() => {\n        // Not dealing with Hex or RGBA so use a canvas to parse the color\n        const canvas = document.createElement('canvas');\n        canvas.height = 1;\n        canvas.width = 1;\n        const canvasContext = canvas.getContext('2d');\n        // all valid colors after this point\n        canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n        // invalid colors will be shown as white - the first assignment will pass and the second may be ignored\n        canvasContext.fillStyle = '#FFFFFF';\n        canvasContext.fillStyle = color;\n        canvasContext.fillRect(0, 0, 1, 1);\n        const rgba = canvasContext.getImageData(0, 0, 1, 1).data;\n        const r = rgba[0];\n        const g = rgba[1];\n        const b = rgba[2];\n        const a = rgba[3];\n        return fromRgba(rgbaColour(r, g, b, a));\n    });\n    const rgbaToHexString = (color) => fromString(color)\n        .map(fromRgba)\n        .map((h) => '#' + h.value)\n        .getOr(color);\n\n    const onSetupToggle = (editor, formatName, formatValue) => {\n        return (api) => {\n            const boundCallback = unbindable();\n            const isNone = isEmpty(formatValue);\n            const init = () => {\n                const selectedCells = getCellsFromSelection(editor);\n                const checkNode = (cell) => editor.formatter.match(formatName, { value: formatValue }, cell.dom, isNone);\n                // If value is empty (A None-entry in the list), check if the format is not set at all. Otherwise, check if the format is set to the correct value.\n                if (isNone) {\n                    api.setActive(!exists(selectedCells, checkNode));\n                    boundCallback.set(editor.formatter.formatChanged(formatName, (match) => api.setActive(!match), true));\n                }\n                else {\n                    api.setActive(forall(selectedCells, checkNode));\n                    boundCallback.set(editor.formatter.formatChanged(formatName, api.setActive, false, { value: formatValue }));\n                }\n            };\n            // The editor may or may not have been setup yet, so check for that\n            editor.initialized ? init() : editor.on('init', init);\n            return boundCallback.clear;\n        };\n    };\n    const isListGroup = (item) => hasNonNullableKey(item, 'menu');\n    const buildListItems = (items) => map(items, (item) => {\n        // item.text is not documented - maybe deprecated option we can delete??\n        const text = item.text || item.title || '';\n        if (isListGroup(item)) {\n            return {\n                text,\n                items: buildListItems(item.menu)\n            };\n        }\n        else {\n            return {\n                text,\n                value: item.value\n            };\n        }\n    });\n    const buildClassList = (classList) => {\n        if (!classList.length) {\n            return Optional.none();\n        }\n        return Optional.some(buildListItems([{ text: 'Select...', value: 'mce-no-match' }, ...classList]));\n    };\n    const buildMenuItems = (editor, items, format, onAction) => map(items, (item) => {\n        // item.text is not documented - maybe deprecated option we can delete??\n        const text = item.text || item.title;\n        if (isListGroup(item)) {\n            return {\n                type: 'nestedmenuitem',\n                text,\n                getSubmenuItems: () => buildMenuItems(editor, item.menu, format, onAction)\n            };\n        }\n        else {\n            return {\n                text,\n                type: 'togglemenuitem',\n                onAction: () => onAction(item.value),\n                onSetup: onSetupToggle(editor, format, item.value)\n            };\n        }\n    });\n    const applyTableCellStyle = (editor, style) => (value) => {\n        editor.execCommand('mceTableApplyCellStyle', false, { [style]: value });\n    };\n    const filterNoneItem = (list) => bind(list, (item) => {\n        if (isListGroup(item)) {\n            return [{ ...item, menu: filterNoneItem(item.menu) }];\n        }\n        else {\n            return isNotEmpty(item.value) ? [item] : [];\n        }\n    });\n    const generateMenuItemsCallback = (editor, items, format, onAction) => (callback) => callback(buildMenuItems(editor, items, format, onAction));\n    const buildColorMenu = (editor, colorList, style) => {\n        const colorMap = map(colorList, (entry) => ({\n            text: entry.title,\n            value: '#' + anyToHex(entry.value).value,\n            type: 'choiceitem'\n        }));\n        return [{\n                type: 'fancymenuitem',\n                fancytype: 'colorswatch',\n                initData: {\n                    colors: colorMap.length > 0 ? colorMap : undefined,\n                    allowCustomColors: false\n                },\n                onAction: (data) => {\n                    const value = data.value === 'remove' ? '' : data.value;\n                    editor.execCommand('mceTableApplyCellStyle', false, { [style]: value });\n                }\n            }];\n    };\n    const changeRowHeader = (editor) => () => {\n        const currentType = editor.queryCommandValue('mceTableRowType');\n        const newType = currentType === 'header' ? 'body' : 'header';\n        editor.execCommand('mceTableRowType', false, { type: newType });\n    };\n    const changeColumnHeader = (editor) => () => {\n        const currentType = editor.queryCommandValue('mceTableColType');\n        const newType = currentType === 'th' ? 'td' : 'th';\n        editor.execCommand('mceTableColType', false, { type: newType });\n    };\n\n    const getClassList$1 = (editor) => buildClassList(getCellClassList(editor))\n        .map((items) => ({\n        name: 'class',\n        type: 'listbox',\n        label: 'Class',\n        items\n    }));\n    const children = [\n        {\n            name: 'width',\n            type: 'input',\n            label: 'Width'\n        },\n        {\n            name: 'celltype',\n            type: 'listbox',\n            label: 'Cell type',\n            items: [\n                { text: 'Cell', value: 'td' },\n                { text: 'Header cell', value: 'th' }\n            ]\n        },\n        {\n            name: 'scope',\n            type: 'listbox',\n            label: 'Scope',\n            items: [\n                { text: 'None', value: '' },\n                { text: 'Row', value: 'row' },\n                { text: 'Column', value: 'col' },\n                { text: 'Row group', value: 'rowgroup' },\n                { text: 'Column group', value: 'colgroup' }\n            ]\n        },\n        {\n            name: 'halign',\n            type: 'listbox',\n            label: 'Horizontal align',\n            items: [\n                { text: 'None', value: '' },\n                { text: 'Left', value: 'left' },\n                { text: 'Center', value: 'center' },\n                { text: 'Right', value: 'right' }\n            ]\n        },\n        {\n            name: 'valign',\n            type: 'listbox',\n            label: 'Vertical align',\n            items: verticalAlignValues\n        }\n    ];\n    const getItems$2 = (editor) => children.concat(getClassList$1(editor).toArray());\n\n    const getAdvancedTab = (editor, dialogName) => {\n        const emptyBorderStyle = [{ text: 'Select...', value: '' }];\n        const advTabItems = [\n            {\n                name: 'borderstyle',\n                type: 'listbox',\n                label: 'Border style',\n                items: emptyBorderStyle.concat(buildListItems(getTableBorderStyles(editor)))\n            },\n            {\n                name: 'bordercolor',\n                type: 'colorinput',\n                label: 'Border color'\n            },\n            {\n                name: 'backgroundcolor',\n                type: 'colorinput',\n                label: 'Background color'\n            }\n        ];\n        const borderWidth = {\n            name: 'borderwidth',\n            type: 'input',\n            label: 'Border width'\n        };\n        const items = dialogName === 'cell' ? [borderWidth].concat(advTabItems) : advTabItems;\n        return {\n            title: 'Advanced',\n            name: 'advanced',\n            items\n        };\n    };\n\n    // The get node is required here because it can be transformed\n    // when switching between tags (e.g. th and td)\n    const normal = (editor, element) => {\n        const dom = editor.dom;\n        const setAttrib = (attr, value) => {\n            dom.setAttrib(element, attr, value);\n        };\n        const setStyle = (prop, value) => {\n            dom.setStyle(element, prop, value);\n        };\n        const setFormat = (formatName, value) => {\n            // Remove format if given an empty string\n            if (value === '') {\n                editor.formatter.remove(formatName, { value: null }, element, true);\n            }\n            else {\n                editor.formatter.apply(formatName, { value }, element);\n            }\n        };\n        return {\n            setAttrib,\n            setStyle,\n            setFormat\n        };\n    };\n    const DomModifier = {\n        normal\n    };\n\n    const rgbToHex = (value) => startsWith(value, 'rgb') ? rgbaToHexString(value) : value;\n    const extractAdvancedStyles = (elm) => {\n        const element = SugarElement.fromDom(elm);\n        return {\n            borderwidth: getRaw$1(element, 'border-width').getOr(''),\n            borderstyle: getRaw$1(element, 'border-style').getOr(''),\n            bordercolor: getRaw$1(element, 'border-color').map(rgbToHex).getOr(''),\n            backgroundcolor: getRaw$1(element, 'background-color').map(rgbToHex).getOr('')\n        };\n    };\n    const getSharedValues = (data) => {\n        // TODO surely there's a better way to do this??\n        // Mutates baseData to return an object that contains only the values\n        // that were the same across all objects in data\n        const baseData = data[0];\n        const comparisonData = data.slice(1);\n        each$1(comparisonData, (items) => {\n            each$1(keys(baseData), (key) => {\n                each(items, (itemValue, itemKey) => {\n                    const comparisonValue = baseData[key];\n                    if (comparisonValue !== '' && key === itemKey) {\n                        if (comparisonValue !== itemValue) {\n                            baseData[key] = key === 'class' ? 'mce-no-match' : '';\n                        }\n                    }\n                });\n            });\n        });\n        return baseData;\n    };\n    // The extractDataFrom... functions are in this file partly for code reuse and partly so we can test them,\n    // because some of these are crazy complicated\n    const getAlignment = (formats, formatName, editor, elm) => find(formats, (name) => !isUndefined(editor.formatter.matchNode(elm, formatName + name))).getOr('');\n    const getHAlignment = curry(getAlignment, ['left', 'center', 'right'], 'align');\n    const getVAlignment = curry(getAlignment, ['top', 'middle', 'bottom'], 'valign');\n    const extractDataFromSettings = (editor, hasAdvTableTab) => {\n        const style = getDefaultStyles(editor);\n        const attrs = getDefaultAttributes(editor);\n        const extractAdvancedStyleData = () => ({\n            borderstyle: get$3(style, 'border-style').getOr(''),\n            bordercolor: rgbToHex(get$3(style, 'border-color').getOr('')),\n            backgroundcolor: rgbToHex(get$3(style, 'background-color').getOr(''))\n        });\n        const defaultData = {\n            height: '',\n            width: '100%',\n            cellspacing: '',\n            cellpadding: '',\n            caption: false,\n            class: '',\n            align: '',\n            border: ''\n        };\n        const getBorder = () => {\n            const borderWidth = style['border-width'];\n            if (shouldStyleWithCss(editor) && borderWidth) {\n                return { border: borderWidth };\n            }\n            return get$3(attrs, 'border').fold(() => ({}), (border) => ({ border }));\n        };\n        const advStyle = (hasAdvTableTab ? extractAdvancedStyleData() : {});\n        const getCellPaddingCellSpacing = () => {\n            const spacing = get$3(style, 'border-spacing').or(get$3(attrs, 'cellspacing')).fold(() => ({}), (cellspacing) => ({ cellspacing }));\n            const padding = get$3(style, 'border-padding').or(get$3(attrs, 'cellpadding')).fold(() => ({}), (cellpadding) => ({ cellpadding }));\n            return {\n                ...spacing,\n                ...padding\n            };\n        };\n        const data = {\n            ...defaultData,\n            ...style,\n            ...attrs,\n            ...advStyle,\n            ...getBorder(),\n            ...getCellPaddingCellSpacing()\n        };\n        return data;\n    };\n    const getRowType = (elm) => table(SugarElement.fromDom(elm)).map((table) => {\n        const target = { selection: fromDom(elm.cells) };\n        return getRowsType(table, target);\n    }).getOr('');\n    const extractDataFromTableElement = (editor, elm, hasAdvTableTab) => {\n        const getBorder = (dom, elm) => {\n            // Cases (in order to check):\n            // 1. shouldStyleWithCss - extract border-width style if it exists\n            // 2. !shouldStyleWithCss && border attribute - set border attribute as value\n            // 3. !shouldStyleWithCss && nothing on the table - grab styles from the first th or td\n            const optBorderWidth = getRaw$1(SugarElement.fromDom(elm), 'border-width');\n            if (shouldStyleWithCss(editor) && optBorderWidth.isSome()) {\n                return optBorderWidth.getOr('');\n            }\n            return dom.getAttrib(elm, 'border') || getTDTHOverallStyle(editor.dom, elm, 'border-width')\n                || getTDTHOverallStyle(editor.dom, elm, 'border') || '';\n        };\n        const dom = editor.dom;\n        const cellspacing = shouldStyleWithCss(editor) ?\n            dom.getStyle(elm, 'border-spacing') || dom.getAttrib(elm, 'cellspacing') :\n            dom.getAttrib(elm, 'cellspacing') || dom.getStyle(elm, 'border-spacing');\n        const cellpadding = shouldStyleWithCss(editor) ?\n            getTDTHOverallStyle(dom, elm, 'padding') || dom.getAttrib(elm, 'cellpadding') :\n            dom.getAttrib(elm, 'cellpadding') || getTDTHOverallStyle(dom, elm, 'padding');\n        return {\n            width: dom.getStyle(elm, 'width') || dom.getAttrib(elm, 'width'),\n            height: dom.getStyle(elm, 'height') || dom.getAttrib(elm, 'height'),\n            cellspacing: cellspacing !== null && cellspacing !== void 0 ? cellspacing : '',\n            cellpadding: cellpadding !== null && cellpadding !== void 0 ? cellpadding : '',\n            border: getBorder(dom, elm),\n            caption: !!dom.select('caption', elm)[0],\n            class: dom.getAttrib(elm, 'class', ''),\n            align: getHAlignment(editor, elm),\n            ...(hasAdvTableTab ? extractAdvancedStyles(elm) : {})\n        };\n    };\n    const extractDataFromRowElement = (editor, elm, hasAdvancedRowTab) => {\n        const dom = editor.dom;\n        return {\n            height: dom.getStyle(elm, 'height') || dom.getAttrib(elm, 'height'),\n            class: dom.getAttrib(elm, 'class', ''),\n            type: getRowType(elm),\n            align: getHAlignment(editor, elm),\n            ...(hasAdvancedRowTab ? extractAdvancedStyles(elm) : {})\n        };\n    };\n    const extractDataFromCellElement = (editor, cell, hasAdvancedCellTab, column) => {\n        const dom = editor.dom;\n        const colElm = column.getOr(cell);\n        const getStyle = (element, style) => dom.getStyle(element, style) || dom.getAttrib(element, style);\n        return {\n            width: getStyle(colElm, 'width'),\n            scope: dom.getAttrib(cell, 'scope'),\n            celltype: getNodeName(cell),\n            class: dom.getAttrib(cell, 'class', ''),\n            halign: getHAlignment(editor, cell),\n            valign: getVAlignment(editor, cell),\n            ...(hasAdvancedCellTab ? extractAdvancedStyles(cell) : {})\n        };\n    };\n\n    const getSelectedCells = (table, cells) => {\n        const warehouse = Warehouse.fromTable(table);\n        const allCells = Warehouse.justCells(warehouse);\n        const filtered = filter$1(allCells, (cellA) => exists(cells, (cellB) => eq(cellA.element, cellB)));\n        return map(filtered, (cell) => ({\n            element: cell.element.dom,\n            column: Warehouse.getColumnAt(warehouse, cell.column).map((col) => col.element.dom)\n        }));\n    };\n    const updateSimpleProps$1 = (modifier, colModifier, data, shouldUpdate) => {\n        if (shouldUpdate('scope')) {\n            modifier.setAttrib('scope', data.scope);\n        }\n        if (shouldUpdate('class') && data.class !== 'mce-no-match') {\n            modifier.setAttrib('class', data.class);\n        }\n        if (shouldUpdate('width')) {\n            colModifier.setStyle('width', addPxSuffix(data.width));\n        }\n    };\n    const updateAdvancedProps$1 = (modifier, data, shouldUpdate) => {\n        if (shouldUpdate('backgroundcolor')) {\n            modifier.setFormat('tablecellbackgroundcolor', data.backgroundcolor);\n        }\n        if (shouldUpdate('bordercolor')) {\n            modifier.setFormat('tablecellbordercolor', data.bordercolor);\n        }\n        if (shouldUpdate('borderstyle')) {\n            modifier.setFormat('tablecellborderstyle', data.borderstyle);\n        }\n        if (shouldUpdate('borderwidth')) {\n            modifier.setFormat('tablecellborderwidth', addPxSuffix(data.borderwidth));\n        }\n    };\n    const applyStyleData$1 = (editor, cells, data, wasChanged) => {\n        const isSingleCell = cells.length === 1;\n        each$1(cells, (item) => {\n            const cellElm = item.element;\n            const shouldOverrideCurrentValue = isSingleCell ? always : wasChanged;\n            const modifier = DomModifier.normal(editor, cellElm);\n            const colModifier = item.column.map((col) => DomModifier.normal(editor, col)).getOr(modifier);\n            updateSimpleProps$1(modifier, colModifier, data, shouldOverrideCurrentValue);\n            if (hasAdvancedCellTab(editor)) {\n                updateAdvancedProps$1(modifier, data, shouldOverrideCurrentValue);\n            }\n            // Apply alignment\n            if (wasChanged('halign')) {\n                setAlign(editor, cellElm, data.halign);\n            }\n            // Apply vertical alignment\n            if (wasChanged('valign')) {\n                setVAlign(editor, cellElm, data.valign);\n            }\n        });\n    };\n    const applyStructureData$1 = (editor, data) => {\n        // Switch cell type if applicable. Note that we specifically tell the command to not fire events\n        // as we'll batch the events and fire a `TableModified` event at the end of the updates.\n        editor.execCommand('mceTableCellType', false, { type: data.celltype, no_events: true });\n    };\n    const applyCellData = (editor, cells, oldData, data) => {\n        const modifiedData = filter(data, (value, key) => oldData[key] !== value);\n        if (size(modifiedData) > 0 && cells.length >= 1) {\n            // Retrieve the table before the cells are modified as there is a case where cells\n            // are replaced and the reference will be lost when trying to fire events.\n            table(cells[0]).each((table) => {\n                const selectedCells = getSelectedCells(table, cells);\n                // style modified if there's at least one other change apart from 'celltype' and 'scope'\n                const styleModified = size(filter(modifiedData, (_value, key) => key !== 'scope' && key !== 'celltype')) > 0;\n                const structureModified = has(modifiedData, 'celltype');\n                // Update the cells styling using the dialog data\n                if (styleModified || has(modifiedData, 'scope')) {\n                    applyStyleData$1(editor, selectedCells, data, curry(has, modifiedData));\n                }\n                // Update the cells structure using the dialog data\n                if (structureModified) {\n                    applyStructureData$1(editor, data);\n                }\n                fireTableModified(editor, table.dom, {\n                    structure: structureModified,\n                    style: styleModified,\n                });\n            });\n        }\n    };\n    const onSubmitCellForm = (editor, cells, oldData, api) => {\n        const data = api.getData();\n        api.close();\n        editor.undoManager.transact(() => {\n            applyCellData(editor, cells, oldData, data);\n            editor.focus();\n        });\n    };\n    const getData$1 = (editor, cells) => {\n        const cellsData = table(cells[0]).map((table) => map(getSelectedCells(table, cells), (item) => extractDataFromCellElement(editor, item.element, hasAdvancedCellTab(editor), item.column)));\n        return getSharedValues(cellsData.getOrDie());\n    };\n    const open$2 = (editor) => {\n        const cells = getCellsFromSelection(editor);\n        // Check if there are any cells to operate on\n        if (cells.length === 0) {\n            return;\n        }\n        const data = getData$1(editor, cells);\n        const dialogTabPanel = {\n            type: 'tabpanel',\n            tabs: [\n                {\n                    title: 'General',\n                    name: 'general',\n                    items: getItems$2(editor)\n                },\n                getAdvancedTab(editor, 'cell')\n            ]\n        };\n        const dialogPanel = {\n            type: 'panel',\n            items: [\n                {\n                    type: 'grid',\n                    columns: 2,\n                    items: getItems$2(editor)\n                }\n            ]\n        };\n        editor.windowManager.open({\n            title: 'Cell Properties',\n            size: 'normal',\n            body: hasAdvancedCellTab(editor) ? dialogTabPanel : dialogPanel,\n            buttons: [\n                {\n                    type: 'cancel',\n                    name: 'cancel',\n                    text: 'Cancel'\n                },\n                {\n                    type: 'submit',\n                    name: 'save',\n                    text: 'Save',\n                    primary: true\n                }\n            ],\n            initialData: data,\n            onSubmit: curry(onSubmitCellForm, editor, cells, data)\n        });\n    };\n\n    const getClassList = (editor) => buildClassList(getRowClassList(editor))\n        .map((items) => ({\n        name: 'class',\n        type: 'listbox',\n        label: 'Class',\n        items\n    }));\n    const formChildren = [\n        {\n            type: 'listbox',\n            name: 'type',\n            label: 'Row type',\n            items: [\n                { text: 'Header', value: 'header' },\n                { text: 'Body', value: 'body' },\n                { text: 'Footer', value: 'footer' }\n            ]\n        },\n        {\n            type: 'listbox',\n            name: 'align',\n            label: 'Alignment',\n            items: [\n                { text: 'None', value: '' },\n                { text: 'Left', value: 'left' },\n                { text: 'Center', value: 'center' },\n                { text: 'Right', value: 'right' }\n            ]\n        },\n        {\n            label: 'Height',\n            name: 'height',\n            type: 'input'\n        }\n    ];\n    const getItems$1 = (editor) => formChildren.concat(getClassList(editor).toArray());\n\n    const updateSimpleProps = (modifier, data, shouldUpdate) => {\n        if (shouldUpdate('class') && data.class !== 'mce-no-match') {\n            modifier.setAttrib('class', data.class);\n        }\n        if (shouldUpdate('height')) {\n            modifier.setStyle('height', addPxSuffix(data.height));\n        }\n    };\n    const updateAdvancedProps = (modifier, data, shouldUpdate) => {\n        if (shouldUpdate('backgroundcolor')) {\n            modifier.setStyle('background-color', data.backgroundcolor);\n        }\n        if (shouldUpdate('bordercolor')) {\n            modifier.setStyle('border-color', data.bordercolor);\n        }\n        if (shouldUpdate('borderstyle')) {\n            modifier.setStyle('border-style', data.borderstyle);\n        }\n    };\n    const applyStyleData = (editor, rows, data, wasChanged) => {\n        const isSingleRow = rows.length === 1;\n        const shouldOverrideCurrentValue = isSingleRow ? always : wasChanged;\n        each$1(rows, (rowElm) => {\n            const rowCells = children$1(SugarElement.fromDom(rowElm), 'td,th');\n            const modifier = DomModifier.normal(editor, rowElm);\n            updateSimpleProps(modifier, data, shouldOverrideCurrentValue);\n            if (hasAdvancedRowTab(editor)) {\n                updateAdvancedProps(modifier, data, shouldOverrideCurrentValue);\n            }\n            // TINY-10617: Simplify number of height styles when applying height on tr\n            if (wasChanged('height')) {\n                each$1(rowCells, (cell) => {\n                    editor.dom.setStyle(cell.dom, 'height', null);\n                });\n            }\n            if (wasChanged('align')) {\n                setAlign(editor, rowElm, data.align);\n            }\n        });\n    };\n    const applyStructureData = (editor, data) => {\n        // Switch cell type if applicable. Note that we specifically tell the command to not fire events\n        // as we'll batch the events and fire a `TableModified` event at the end of the updates.\n        editor.execCommand('mceTableRowType', false, { type: data.type, no_events: true });\n    };\n    const applyRowData = (editor, rows, oldData, data) => {\n        const modifiedData = filter(data, (value, key) => oldData[key] !== value);\n        if (size(modifiedData) > 0) {\n            const typeModified = has(modifiedData, 'type');\n            // style modified if there's at least one other change apart from 'type'\n            const styleModified = typeModified ? size(modifiedData) > 1 : true;\n            // Update the rows styling using the dialog data\n            if (styleModified) {\n                applyStyleData(editor, rows, data, curry(has, modifiedData));\n            }\n            // Update the rows structure using the dialog data\n            if (typeModified) {\n                applyStructureData(editor, data);\n            }\n            table(SugarElement.fromDom(rows[0])).each((table) => fireTableModified(editor, table.dom, {\n                structure: typeModified,\n                style: styleModified\n            }));\n        }\n    };\n    const onSubmitRowForm = (editor, rows, oldData, api) => {\n        const data = api.getData();\n        api.close();\n        editor.undoManager.transact(() => {\n            applyRowData(editor, rows, oldData, data);\n            editor.focus();\n        });\n    };\n    const open$1 = (editor) => {\n        const rows = getRowsFromSelection(getSelectionStart(editor), ephemera.selected);\n        // Check if there are any rows to operate on\n        if (rows.length === 0) {\n            return;\n        }\n        // Get current data and find shared values between rows\n        const rowsData = map(rows, (rowElm) => extractDataFromRowElement(editor, rowElm.dom, hasAdvancedRowTab(editor)));\n        const data = getSharedValues(rowsData);\n        const dialogTabPanel = {\n            type: 'tabpanel',\n            tabs: [\n                {\n                    title: 'General',\n                    name: 'general',\n                    items: getItems$1(editor)\n                },\n                getAdvancedTab(editor, 'row')\n            ]\n        };\n        const dialogPanel = {\n            type: 'panel',\n            items: [\n                {\n                    type: 'grid',\n                    columns: 2,\n                    items: getItems$1(editor)\n                }\n            ]\n        };\n        editor.windowManager.open({\n            title: 'Row Properties',\n            size: 'normal',\n            body: hasAdvancedRowTab(editor) ? dialogTabPanel : dialogPanel,\n            buttons: [\n                {\n                    type: 'cancel',\n                    name: 'cancel',\n                    text: 'Cancel'\n                },\n                {\n                    type: 'submit',\n                    name: 'save',\n                    text: 'Save',\n                    primary: true\n                }\n            ],\n            initialData: data,\n            onSubmit: curry(onSubmitRowForm, editor, map(rows, (r) => r.dom), data)\n        });\n    };\n\n    const getItems = (editor, classes, insertNewTable) => {\n        const rowColCountItems = !insertNewTable ? [] : [\n            {\n                type: 'input',\n                name: 'cols',\n                label: 'Cols',\n                inputMode: 'numeric'\n            },\n            {\n                type: 'input',\n                name: 'rows',\n                label: 'Rows',\n                inputMode: 'numeric'\n            }\n        ];\n        const alwaysItems = [\n            {\n                type: 'input',\n                name: 'width',\n                label: 'Width'\n            },\n            {\n                type: 'input',\n                name: 'height',\n                label: 'Height'\n            }\n        ];\n        const appearanceItems = hasAppearanceOptions(editor) ? [\n            {\n                type: 'input',\n                name: 'cellspacing',\n                label: 'Cell spacing',\n                inputMode: 'numeric'\n            },\n            {\n                type: 'input',\n                name: 'cellpadding',\n                label: 'Cell padding',\n                inputMode: 'numeric'\n            },\n            {\n                type: 'input',\n                name: 'border',\n                label: 'Border width'\n            },\n            {\n                type: 'label',\n                label: 'Caption',\n                items: [\n                    {\n                        type: 'checkbox',\n                        name: 'caption',\n                        label: 'Show caption'\n                    }\n                ]\n            }\n        ] : [];\n        const alignmentItem = [\n            {\n                type: 'listbox',\n                name: 'align',\n                label: 'Alignment',\n                items: [\n                    { text: 'None', value: '' },\n                    { text: 'Left', value: 'left' },\n                    { text: 'Center', value: 'center' },\n                    { text: 'Right', value: 'right' }\n                ]\n            }\n        ];\n        const classListItem = classes.length > 0 ? [\n            {\n                name: 'class',\n                type: 'listbox',\n                label: 'Class',\n                items: classes\n            }\n        ] : [];\n        return rowColCountItems.concat(alwaysItems).concat(appearanceItems).concat(alignmentItem).concat(classListItem);\n    };\n\n    // Explore the layers of the table till we find the first layer of tds or ths\n    const styleTDTH = (dom, elm, name, value) => {\n        if (elm.tagName === 'TD' || elm.tagName === 'TH') {\n            if (isString(name) && isNonNullable(value)) {\n                dom.setStyle(elm, name, value);\n            }\n            else {\n                dom.setStyles(elm, name);\n            }\n        }\n        else {\n            if (elm.children) {\n                for (let i = 0; i < elm.children.length; i++) {\n                    styleTDTH(dom, elm.children[i], name, value);\n                }\n            }\n        }\n    };\n    const applyDataToElement = (editor, tableElm, data, shouldApplyOnCell) => {\n        const dom = editor.dom;\n        const attrs = {};\n        const styles = {};\n        const shouldStyleWithCss$1 = shouldStyleWithCss(editor);\n        const hasAdvancedTableTab$1 = hasAdvancedTableTab(editor);\n        const borderIsZero = parseFloat(data.border) === 0;\n        if (!isUndefined(data.class) && data.class !== 'mce-no-match') {\n            attrs.class = data.class;\n        }\n        styles.height = addPxSuffix(data.height);\n        if (shouldStyleWithCss$1) {\n            styles.width = addPxSuffix(data.width);\n        }\n        else if (dom.getAttrib(tableElm, 'width')) {\n            attrs.width = removePxSuffix(data.width);\n        }\n        if (shouldStyleWithCss$1) {\n            if (borderIsZero) {\n                attrs.border = 0;\n                styles['border-width'] = '';\n            }\n            else {\n                styles['border-width'] = addPxSuffix(data.border);\n                attrs.border = 1;\n            }\n            styles['border-spacing'] = addPxSuffix(data.cellspacing);\n        }\n        else {\n            attrs.border = borderIsZero ? 0 : data.border;\n            attrs.cellpadding = data.cellpadding;\n            attrs.cellspacing = data.cellspacing;\n        }\n        // TINY-9837: Relevant data are applied on child TD/THs only if they have been modified since the previous dialog submission\n        if (shouldStyleWithCss$1 && tableElm.children) {\n            const cellStyles = {};\n            if (borderIsZero) {\n                cellStyles['border-width'] = '';\n            }\n            else if (shouldApplyOnCell.border) {\n                cellStyles['border-width'] = addPxSuffix(data.border);\n            }\n            if (shouldApplyOnCell.cellpadding) {\n                cellStyles.padding = addPxSuffix(data.cellpadding);\n            }\n            if (hasAdvancedTableTab$1 && shouldApplyOnCell.bordercolor) {\n                cellStyles['border-color'] = data.bordercolor;\n            }\n            if (!isEmpty$1(cellStyles)) {\n                for (let i = 0; i < tableElm.children.length; i++) {\n                    styleTDTH(dom, tableElm.children[i], cellStyles);\n                }\n            }\n        }\n        if (hasAdvancedTableTab$1) {\n            const advData = data;\n            styles['background-color'] = advData.backgroundcolor;\n            styles['border-color'] = advData.bordercolor;\n            styles['border-style'] = advData.borderstyle;\n        }\n        dom.setStyles(tableElm, { ...getDefaultStyles(editor), ...styles });\n        dom.setAttribs(tableElm, { ...getDefaultAttributes(editor), ...attrs });\n    };\n    const onSubmitTableForm = (editor, tableElm, oldData, api) => {\n        const dom = editor.dom;\n        const data = api.getData();\n        const modifiedData = filter(data, (value, key) => oldData[key] !== value);\n        api.close();\n        editor.undoManager.transact(() => {\n            if (!tableElm) {\n                const cols = toInt(data.cols).getOr(1);\n                const rows = toInt(data.rows).getOr(1);\n                // Cases 1 & 3 - inserting a table\n                editor.execCommand('mceInsertTable', false, { rows, columns: cols });\n                tableElm = getSelectionCell(getSelectionStart(editor), getIsRoot(editor))\n                    .bind((cell) => table(cell, getIsRoot(editor)))\n                    .map((table) => table.dom)\n                    .getOrDie();\n            }\n            if (size(modifiedData) > 0) {\n                const applicableCellProperties = {\n                    border: has(modifiedData, 'border'),\n                    bordercolor: has(modifiedData, 'bordercolor'),\n                    cellpadding: has(modifiedData, 'cellpadding')\n                };\n                applyDataToElement(editor, tableElm, data, applicableCellProperties);\n                // Toggle caption on/off\n                const captionElm = dom.select('caption', tableElm)[0];\n                if (captionElm && !data.caption || !captionElm && data.caption) {\n                    editor.execCommand('mceTableToggleCaption');\n                }\n                setAlign(editor, tableElm, data.align);\n            }\n            editor.focus();\n            editor.addVisual();\n            if (size(modifiedData) > 0) {\n                const captionModified = has(modifiedData, 'caption');\n                // style modified if there's at least one other change apart from 'caption'\n                const styleModified = captionModified ? size(modifiedData) > 1 : true;\n                fireTableModified(editor, tableElm, { structure: captionModified, style: styleModified });\n            }\n        });\n    };\n    const open = (editor, insertNewTable) => {\n        const dom = editor.dom;\n        let tableElm;\n        let data = extractDataFromSettings(editor, hasAdvancedTableTab(editor));\n        // Cases for creation/update of tables:\n        // 1. isNew == true - called by mceInsertTable - we are inserting a new table so we don't care what the selection's parent is,\n        //    and we need to add cols and rows input fields to the dialog\n        // 2. isNew == false && selection parent is a table - update the table\n        // 3. isNew == false && selection parent isn't a table - open dialog with default values and insert a table\n        if (insertNewTable) {\n            // Case 1 - isNew == true. We're inserting a new table so use defaults and add cols and rows + adv properties.\n            data.cols = '1';\n            data.rows = '1';\n            if (hasAdvancedTableTab(editor)) {\n                data.borderstyle = '';\n                data.bordercolor = '';\n                data.backgroundcolor = '';\n            }\n        }\n        else {\n            tableElm = dom.getParent(editor.selection.getStart(), 'table', editor.getBody());\n            if (tableElm) {\n                // Case 2 - isNew == false && table parent\n                data = extractDataFromTableElement(editor, tableElm, hasAdvancedTableTab(editor));\n            }\n            else {\n                // Case 3 - isNew == false && non-table parent. data is set to basic defaults so just add the adv properties if needed\n                if (hasAdvancedTableTab(editor)) {\n                    data.borderstyle = '';\n                    data.bordercolor = '';\n                    data.backgroundcolor = '';\n                }\n            }\n        }\n        const classes = buildClassList(getTableClassList(editor));\n        if (classes.isSome()) {\n            if (data.class) {\n                data.class = data.class.replace(/\\s*mce\\-item\\-table\\s*/g, '');\n            }\n        }\n        const generalPanel = {\n            type: 'grid',\n            columns: 2,\n            items: getItems(editor, classes.getOr([]), insertNewTable)\n        };\n        const nonAdvancedForm = () => ({\n            type: 'panel',\n            items: [generalPanel]\n        });\n        const advancedForm = () => ({\n            type: 'tabpanel',\n            tabs: [\n                {\n                    title: 'General',\n                    name: 'general',\n                    items: [generalPanel]\n                },\n                getAdvancedTab(editor, 'table')\n            ]\n        });\n        const dialogBody = hasAdvancedTableTab(editor) ? advancedForm() : nonAdvancedForm();\n        editor.windowManager.open({\n            title: 'Table Properties',\n            size: 'normal',\n            body: dialogBody,\n            onSubmit: curry(onSubmitTableForm, editor, tableElm, data),\n            buttons: [\n                {\n                    type: 'cancel',\n                    name: 'cancel',\n                    text: 'Cancel'\n                },\n                {\n                    type: 'submit',\n                    name: 'save',\n                    text: 'Save',\n                    primary: true\n                }\n            ],\n            initialData: data\n        });\n    };\n\n    const registerCommands = (editor) => {\n        const runAction = (f) => {\n            if (isInEditableContext(getSelectionStart(editor))) {\n                f();\n            }\n        };\n        // Register dialog commands\n        each({\n            // AP-101 TableDialog.open renders a slightly different dialog if isNew is true\n            mceTableProps: curry(open, editor, false),\n            mceTableRowProps: curry(open$1, editor),\n            mceTableCellProps: curry(open$2, editor),\n            mceInsertTableDialog: curry(open, editor, true),\n        }, (func, name) => editor.addCommand(name, () => runAction(func)));\n    };\n\n    /*\n     NOTE: This file is partially duplicated in the following locations:\n      - models/dom/table/queries/TableTargets.ts\n      - advtable\n     Make sure that if making changes to this file, the other files are updated as well\n     */\n    const noMenu = (cell) => ({\n        element: cell,\n        mergable: Optional.none(),\n        unmergable: Optional.none(),\n        selection: [cell]\n    });\n    const forMenu = (selectedCells, table, cell) => ({\n        element: cell,\n        mergable: mergable(table, selectedCells, ephemera),\n        unmergable: unmergable(selectedCells),\n        selection: selection(selectedCells)\n    });\n\n    const getSelectionTargets = (editor) => {\n        const targets = Cell(Optional.none());\n        const changeHandlers = Cell([]);\n        let selectionDetails = Optional.none();\n        const isCaption = isTag('caption');\n        const isDisabledForSelection = (key) => selectionDetails.forall((details) => !details[key]);\n        const getStart = () => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor));\n        const getEnd = () => getSelectionCellOrCaption(getSelectionEnd(editor), getIsRoot(editor));\n        const findTargets = () => getStart().bind((startCellOrCaption) => flatten(lift2(table(startCellOrCaption), getEnd().bind(table), (startTable, endTable) => {\n            if (eq(startTable, endTable)) {\n                if (isCaption(startCellOrCaption)) {\n                    return Optional.some(noMenu(startCellOrCaption));\n                }\n                else {\n                    return Optional.some(forMenu(getCellsFromSelection(editor), startTable, startCellOrCaption));\n                }\n            }\n            return Optional.none();\n        })));\n        const getExtractedDetails = (targets) => {\n            const tableOpt = table(targets.element);\n            return tableOpt.map((table) => {\n                const warehouse = Warehouse.fromTable(table);\n                const selectedCells = onCells(warehouse, targets).getOr([]);\n                const locked = foldl(selectedCells, (acc, cell) => {\n                    if (cell.isLocked) {\n                        acc.onAny = true;\n                        if (cell.column === 0) {\n                            acc.onFirst = true;\n                        }\n                        else if (cell.column + cell.colspan >= warehouse.grid.columns) {\n                            acc.onLast = true;\n                        }\n                    }\n                    return acc;\n                }, { onAny: false, onFirst: false, onLast: false });\n                return {\n                    mergeable: onUnlockedMergable(warehouse, targets).isSome(),\n                    unmergeable: onUnlockedUnmergable(warehouse, targets).isSome(),\n                    locked\n                };\n            });\n        };\n        const resetTargets = () => {\n            // Reset the targets\n            targets.set(cached(findTargets)());\n            // Reset the selection details\n            selectionDetails = targets.get().bind(getExtractedDetails);\n            // Trigger change handlers\n            each$1(changeHandlers.get(), call);\n        };\n        const setupHandler = (handler) => {\n            // Execute the handler to set the initial state\n            handler();\n            // Register the handler so we can update the state when resetting targets\n            changeHandlers.set(changeHandlers.get().concat([handler]));\n            return () => {\n                changeHandlers.set(filter$1(changeHandlers.get(), (h) => h !== handler));\n            };\n        };\n        const onSetup = (api, isDisabled) => setupHandler(() => targets.get().fold(() => {\n            api.setEnabled(false);\n        }, (targets) => {\n            api.setEnabled(!isDisabled(targets) && editor.selection.isEditable());\n        }));\n        const onSetupWithToggle = (api, isDisabled, isActive) => setupHandler(() => targets.get().fold(() => {\n            api.setEnabled(false);\n            api.setActive(false);\n        }, (targets) => {\n            api.setEnabled(!isDisabled(targets) && editor.selection.isEditable());\n            api.setActive(isActive(targets));\n        }));\n        const isDisabledFromLocked = (lockedDisable) => selectionDetails.exists((details) => details.locked[lockedDisable]);\n        const onSetupTable = (api) => onSetup(api, (_) => false);\n        const onSetupCellOrRow = (api) => onSetup(api, (targets) => isCaption(targets.element));\n        const onSetupColumn = (lockedDisable) => (api) => onSetup(api, (targets) => isCaption(targets.element) || isDisabledFromLocked(lockedDisable));\n        const onSetupPasteable = (getClipboardData) => (api) => onSetup(api, (targets) => isCaption(targets.element) || getClipboardData().isNone());\n        const onSetupPasteableColumn = (getClipboardData, lockedDisable) => (api) => onSetup(api, (targets) => isCaption(targets.element) || getClipboardData().isNone() || isDisabledFromLocked(lockedDisable));\n        const onSetupMergeable = (api) => onSetup(api, (_targets) => isDisabledForSelection('mergeable'));\n        const onSetupUnmergeable = (api) => onSetup(api, (_targets) => isDisabledForSelection('unmergeable'));\n        const onSetupTableWithCaption = (api) => {\n            return onSetupWithToggle(api, never, (targets) => {\n                const tableOpt = table(targets.element, getIsRoot(editor));\n                return tableOpt.exists((table) => child(table, 'caption'));\n            });\n        };\n        const onSetupTableHeaders = (command, headerType) => (api) => {\n            return onSetupWithToggle(api, (targets) => isCaption(targets.element), () => editor.queryCommandValue(command) === headerType);\n        };\n        const onSetupTableRowHeaders = onSetupTableHeaders('mceTableRowType', 'header');\n        const onSetupTableColumnHeaders = onSetupTableHeaders('mceTableColType', 'th');\n        editor.on('NodeChange ExecCommand TableSelectorChange', resetTargets);\n        return {\n            onSetupTable,\n            onSetupCellOrRow,\n            onSetupColumn,\n            onSetupPasteable,\n            onSetupPasteableColumn,\n            onSetupMergeable,\n            onSetupUnmergeable,\n            resetTargets,\n            onSetupTableWithCaption,\n            onSetupTableRowHeaders,\n            onSetupTableColumnHeaders,\n            targets: targets.get\n        };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.FakeClipboard');\n\n    /*\n     NOTE: This file is duplicated in the following locations:\n      - models/dom/table/api/Clipboard.ts\n     Make sure that if making changes to this file, the other files are updated as well\n     */\n    const tableTypeBase = 'x-tinymce/dom-table-';\n    const tableTypeRow = tableTypeBase + 'rows';\n    const tableTypeColumn = tableTypeBase + 'columns';\n    const getData = (type) => {\n        var _a;\n        const items = (_a = global.read()) !== null && _a !== void 0 ? _a : [];\n        return findMap(items, (item) => Optional.from(item.getType(type)));\n    };\n    const getRows = () => getData(tableTypeRow);\n    const getColumns = () => getData(tableTypeColumn);\n\n    const onSetupEditable$1 = (editor) => (api) => {\n        const nodeChanged = () => {\n            api.setEnabled(editor.selection.isEditable());\n        };\n        editor.on('NodeChange', nodeChanged);\n        nodeChanged();\n        return () => {\n            editor.off('NodeChange', nodeChanged);\n        };\n    };\n    const addButtons = (editor, selectionTargets) => {\n        editor.ui.registry.addMenuButton('table', {\n            tooltip: 'Table',\n            icon: 'table',\n            onSetup: onSetupEditable$1(editor),\n            fetch: (callback) => callback('inserttable | cell row column | advtablesort | tableprops deletetable')\n        });\n        const cmd = (command) => () => editor.execCommand(command);\n        // TODO: TINY-8172 Unwind this when an alternative solution is found\n        const addButtonIfRegistered = (name, spec) => {\n            if (editor.queryCommandSupported(spec.command)) {\n                editor.ui.registry.addButton(name, {\n                    ...spec,\n                    onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)\n                });\n            }\n        };\n        // TODO: TINY-8172 Unwind this when an alternative solution is found\n        const addToggleButtonIfRegistered = (name, spec) => {\n            if (editor.queryCommandSupported(spec.command)) {\n                editor.ui.registry.addToggleButton(name, {\n                    ...spec,\n                    onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)\n                });\n            }\n        };\n        addButtonIfRegistered('tableprops', {\n            tooltip: 'Table properties',\n            command: 'mceTableProps',\n            icon: 'table',\n            onSetup: selectionTargets.onSetupTable\n        });\n        addButtonIfRegistered('tabledelete', {\n            tooltip: 'Delete table',\n            command: 'mceTableDelete',\n            icon: 'table-delete-table',\n            onSetup: selectionTargets.onSetupTable\n        });\n        addButtonIfRegistered('tablecellprops', {\n            tooltip: 'Cell properties',\n            command: 'mceTableCellProps',\n            icon: 'table-cell-properties',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tablemergecells', {\n            tooltip: 'Merge cells',\n            command: 'mceTableMergeCells',\n            icon: 'table-merge-cells',\n            onSetup: selectionTargets.onSetupMergeable\n        });\n        addButtonIfRegistered('tablesplitcells', {\n            tooltip: 'Split cell',\n            command: 'mceTableSplitCells',\n            icon: 'table-split-cells',\n            onSetup: selectionTargets.onSetupUnmergeable\n        });\n        addButtonIfRegistered('tableinsertrowbefore', {\n            tooltip: 'Insert row before',\n            command: 'mceTableInsertRowBefore',\n            icon: 'table-insert-row-above',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tableinsertrowafter', {\n            tooltip: 'Insert row after',\n            command: 'mceTableInsertRowAfter',\n            icon: 'table-insert-row-after',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tabledeleterow', {\n            tooltip: 'Delete row',\n            command: 'mceTableDeleteRow',\n            icon: 'table-delete-row',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tablerowprops', {\n            tooltip: 'Row properties',\n            command: 'mceTableRowProps',\n            icon: 'table-row-properties',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tableinsertcolbefore', {\n            tooltip: 'Insert column before',\n            command: 'mceTableInsertColBefore',\n            icon: 'table-insert-column-before',\n            onSetup: selectionTargets.onSetupColumn(\"onFirst\" /* LockedDisable.onFirst */)\n        });\n        addButtonIfRegistered('tableinsertcolafter', {\n            tooltip: 'Insert column after',\n            command: 'mceTableInsertColAfter',\n            icon: 'table-insert-column-after',\n            onSetup: selectionTargets.onSetupColumn(\"onLast\" /* LockedDisable.onLast */)\n        });\n        addButtonIfRegistered('tabledeletecol', {\n            tooltip: 'Delete column',\n            command: 'mceTableDeleteCol',\n            icon: 'table-delete-column',\n            onSetup: selectionTargets.onSetupColumn(\"onAny\" /* LockedDisable.onAny */)\n        });\n        addButtonIfRegistered('tablecutrow', {\n            tooltip: 'Cut row',\n            command: 'mceTableCutRow',\n            icon: 'cut-row',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tablecopyrow', {\n            tooltip: 'Copy row',\n            command: 'mceTableCopyRow',\n            icon: 'duplicate-row',\n            onSetup: selectionTargets.onSetupCellOrRow\n        });\n        addButtonIfRegistered('tablepasterowbefore', {\n            tooltip: 'Paste row before',\n            command: 'mceTablePasteRowBefore',\n            icon: 'paste-row-before',\n            onSetup: selectionTargets.onSetupPasteable(getRows)\n        });\n        addButtonIfRegistered('tablepasterowafter', {\n            tooltip: 'Paste row after',\n            command: 'mceTablePasteRowAfter',\n            icon: 'paste-row-after',\n            onSetup: selectionTargets.onSetupPasteable(getRows)\n        });\n        addButtonIfRegistered('tablecutcol', {\n            tooltip: 'Cut column',\n            command: 'mceTableCutCol',\n            icon: 'cut-column',\n            onSetup: selectionTargets.onSetupColumn(\"onAny\" /* LockedDisable.onAny */)\n        });\n        addButtonIfRegistered('tablecopycol', {\n            tooltip: 'Copy column',\n            command: 'mceTableCopyCol',\n            icon: 'duplicate-column',\n            onSetup: selectionTargets.onSetupColumn(\"onAny\" /* LockedDisable.onAny */)\n        });\n        addButtonIfRegistered('tablepastecolbefore', {\n            tooltip: 'Paste column before',\n            command: 'mceTablePasteColBefore',\n            icon: 'paste-column-before',\n            onSetup: selectionTargets.onSetupPasteableColumn(getColumns, \"onFirst\" /* LockedDisable.onFirst */)\n        });\n        addButtonIfRegistered('tablepastecolafter', {\n            tooltip: 'Paste column after',\n            command: 'mceTablePasteColAfter',\n            icon: 'paste-column-after',\n            onSetup: selectionTargets.onSetupPasteableColumn(getColumns, \"onLast\" /* LockedDisable.onLast */)\n        });\n        addButtonIfRegistered('tableinsertdialog', {\n            tooltip: 'Insert table',\n            command: 'mceInsertTableDialog',\n            icon: 'table',\n            onSetup: onSetupEditable$1(editor)\n        });\n        const tableClassList = filterNoneItem(getTableClassList(editor));\n        if (tableClassList.length !== 0 && editor.queryCommandSupported('mceTableToggleClass')) {\n            editor.ui.registry.addMenuButton('tableclass', {\n                icon: 'table-classes',\n                tooltip: 'Table styles',\n                fetch: generateMenuItemsCallback(editor, tableClassList, 'tableclass', (value) => editor.execCommand('mceTableToggleClass', false, value)),\n                onSetup: selectionTargets.onSetupTable\n            });\n        }\n        const tableCellClassList = filterNoneItem(getCellClassList(editor));\n        if (tableCellClassList.length !== 0 && editor.queryCommandSupported('mceTableCellToggleClass')) {\n            editor.ui.registry.addMenuButton('tablecellclass', {\n                icon: 'table-cell-classes',\n                tooltip: 'Cell styles',\n                fetch: generateMenuItemsCallback(editor, tableCellClassList, 'tablecellclass', (value) => editor.execCommand('mceTableCellToggleClass', false, value)),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n        }\n        // TODO: TINY-8172 Unwind this when an alternative solution is found\n        if (editor.queryCommandSupported('mceTableApplyCellStyle')) {\n            editor.ui.registry.addMenuButton('tablecellvalign', {\n                icon: 'vertical-align',\n                tooltip: 'Vertical align',\n                fetch: generateMenuItemsCallback(editor, verticalAlignValues, 'tablecellverticalalign', applyTableCellStyle(editor, 'vertical-align')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addMenuButton('tablecellborderwidth', {\n                icon: 'border-width',\n                tooltip: 'Border width',\n                fetch: generateMenuItemsCallback(editor, getTableBorderWidths(editor), 'tablecellborderwidth', applyTableCellStyle(editor, 'border-width')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addMenuButton('tablecellborderstyle', {\n                icon: 'border-style',\n                tooltip: 'Border style',\n                fetch: generateMenuItemsCallback(editor, getTableBorderStyles(editor), 'tablecellborderstyle', applyTableCellStyle(editor, 'border-style')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addMenuButton('tablecellbackgroundcolor', {\n                icon: 'cell-background-color',\n                tooltip: 'Background color',\n                fetch: (callback) => callback(buildColorMenu(editor, getTableBackgroundColorMap(editor), 'background-color')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addMenuButton('tablecellbordercolor', {\n                icon: 'cell-border-color',\n                tooltip: 'Border color',\n                fetch: (callback) => callback(buildColorMenu(editor, getTableBorderColorMap(editor), 'border-color')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n        }\n        addToggleButtonIfRegistered('tablecaption', {\n            tooltip: 'Table caption',\n            icon: 'table-caption',\n            command: 'mceTableToggleCaption',\n            onSetup: selectionTargets.onSetupTableWithCaption\n        });\n        addToggleButtonIfRegistered('tablerowheader', {\n            tooltip: 'Row header',\n            icon: 'table-top-header',\n            command: 'mceTableRowType',\n            onAction: changeRowHeader(editor),\n            onSetup: selectionTargets.onSetupTableRowHeaders\n        });\n        addToggleButtonIfRegistered('tablecolheader', {\n            tooltip: 'Column header',\n            icon: 'table-left-header',\n            command: 'mceTableColType',\n            onAction: changeColumnHeader(editor),\n            onSetup: selectionTargets.onSetupTableColumnHeaders\n        });\n    };\n    const addToolbars = (editor) => {\n        const isEditableTable = (table) => editor.dom.is(table, 'table') && editor.getBody().contains(table) && editor.dom.isEditable(table.parentNode);\n        const toolbar = getToolbar(editor);\n        if (toolbar.length > 0) {\n            editor.ui.registry.addContextToolbar('table', {\n                predicate: isEditableTable,\n                items: toolbar,\n                scope: 'node',\n                position: 'node'\n            });\n        }\n    };\n\n    const onSetupEditable = (editor) => (api) => {\n        const nodeChanged = () => {\n            api.setEnabled(editor.selection.isEditable());\n        };\n        editor.on('NodeChange', nodeChanged);\n        nodeChanged();\n        return () => {\n            editor.off('NodeChange', nodeChanged);\n        };\n    };\n    const addMenuItems = (editor, selectionTargets) => {\n        const cmd = (command) => () => editor.execCommand(command);\n        // TODO: TINY-8172 Unwind this when an alternative solution is found\n        const addMenuIfRegistered = (name, spec) => {\n            if (editor.queryCommandSupported(spec.command)) {\n                editor.ui.registry.addMenuItem(name, {\n                    ...spec,\n                    onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)\n                });\n                return true;\n            }\n            else {\n                return false;\n            }\n        };\n        // TODO: TINY-8172 Unwind this when an alternative solution is found\n        const addToggleMenuIfRegistered = (name, spec) => {\n            if (editor.queryCommandSupported(spec.command)) {\n                editor.ui.registry.addToggleMenuItem(name, {\n                    ...spec,\n                    onAction: isFunction(spec.onAction) ? spec.onAction : cmd(spec.command)\n                });\n            }\n        };\n        const insertTableAction = (data) => {\n            editor.execCommand('mceInsertTable', false, {\n                rows: data.numRows,\n                columns: data.numColumns\n            });\n        };\n        const hasRowMenuItems = [\n            addMenuIfRegistered('tableinsertrowbefore', {\n                text: 'Insert row before',\n                icon: 'table-insert-row-above',\n                command: 'mceTableInsertRowBefore',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tableinsertrowafter', {\n                text: 'Insert row after',\n                icon: 'table-insert-row-after',\n                command: 'mceTableInsertRowAfter',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tabledeleterow', {\n                text: 'Delete row',\n                icon: 'table-delete-row',\n                command: 'mceTableDeleteRow',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tablerowprops', {\n                text: 'Row properties',\n                icon: 'table-row-properties',\n                command: 'mceTableRowProps',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tablecutrow', {\n                text: 'Cut row',\n                icon: 'cut-row',\n                command: 'mceTableCutRow',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tablecopyrow', {\n                text: 'Copy row',\n                icon: 'duplicate-row',\n                command: 'mceTableCopyRow',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tablepasterowbefore', {\n                text: 'Paste row before',\n                icon: 'paste-row-before',\n                command: 'mceTablePasteRowBefore',\n                onSetup: selectionTargets.onSetupPasteable(getRows)\n            }),\n            addMenuIfRegistered('tablepasterowafter', {\n                text: 'Paste row after',\n                icon: 'paste-row-after',\n                command: 'mceTablePasteRowAfter',\n                onSetup: selectionTargets.onSetupPasteable(getRows)\n            }),\n        ];\n        const hasColumnMenuItems = [\n            addMenuIfRegistered('tableinsertcolumnbefore', {\n                text: 'Insert column before',\n                icon: 'table-insert-column-before',\n                command: 'mceTableInsertColBefore',\n                onSetup: selectionTargets.onSetupColumn(\"onFirst\" /* LockedDisable.onFirst */)\n            }),\n            addMenuIfRegistered('tableinsertcolumnafter', {\n                text: 'Insert column after',\n                icon: 'table-insert-column-after',\n                command: 'mceTableInsertColAfter',\n                onSetup: selectionTargets.onSetupColumn(\"onLast\" /* LockedDisable.onLast */)\n            }),\n            addMenuIfRegistered('tabledeletecolumn', {\n                text: 'Delete column',\n                icon: 'table-delete-column',\n                command: 'mceTableDeleteCol',\n                onSetup: selectionTargets.onSetupColumn(\"onAny\" /* LockedDisable.onAny */)\n            }),\n            addMenuIfRegistered('tablecutcolumn', {\n                text: 'Cut column',\n                icon: 'cut-column',\n                command: 'mceTableCutCol',\n                onSetup: selectionTargets.onSetupColumn(\"onAny\" /* LockedDisable.onAny */)\n            }),\n            addMenuIfRegistered('tablecopycolumn', {\n                text: 'Copy column',\n                icon: 'duplicate-column',\n                command: 'mceTableCopyCol',\n                onSetup: selectionTargets.onSetupColumn(\"onAny\" /* LockedDisable.onAny */)\n            }),\n            addMenuIfRegistered('tablepastecolumnbefore', {\n                text: 'Paste column before',\n                icon: 'paste-column-before',\n                command: 'mceTablePasteColBefore',\n                onSetup: selectionTargets.onSetupPasteableColumn(getColumns, \"onFirst\" /* LockedDisable.onFirst */)\n            }),\n            addMenuIfRegistered('tablepastecolumnafter', {\n                text: 'Paste column after',\n                icon: 'paste-column-after',\n                command: 'mceTablePasteColAfter',\n                onSetup: selectionTargets.onSetupPasteableColumn(getColumns, \"onLast\" /* LockedDisable.onLast */)\n            }),\n        ];\n        const hasCellMenuItems = [\n            addMenuIfRegistered('tablecellprops', {\n                text: 'Cell properties',\n                icon: 'table-cell-properties',\n                command: 'mceTableCellProps',\n                onSetup: selectionTargets.onSetupCellOrRow\n            }),\n            addMenuIfRegistered('tablemergecells', {\n                text: 'Merge cells',\n                icon: 'table-merge-cells',\n                command: 'mceTableMergeCells',\n                onSetup: selectionTargets.onSetupMergeable\n            }),\n            addMenuIfRegistered('tablesplitcells', {\n                text: 'Split cell',\n                icon: 'table-split-cells',\n                command: 'mceTableSplitCells',\n                onSetup: selectionTargets.onSetupUnmergeable\n            }),\n        ];\n        if (!hasTableGrid(editor)) {\n            editor.ui.registry.addMenuItem('inserttable', {\n                text: 'Table',\n                icon: 'table',\n                onAction: cmd('mceInsertTableDialog'),\n                onSetup: onSetupEditable(editor)\n            });\n        }\n        else {\n            editor.ui.registry.addNestedMenuItem('inserttable', {\n                text: 'Table',\n                icon: 'table',\n                getSubmenuItems: () => [{ type: 'fancymenuitem', fancytype: 'inserttable', onAction: insertTableAction }],\n                onSetup: onSetupEditable(editor)\n            });\n        }\n        // TINY-3636: We want a way to use the dialog even when tablegrid true.\n        // If tablegrid false then inserttable and inserttabledialog are the same,\n        // but that's preferrable to breaking things at this point.\n        editor.ui.registry.addMenuItem('inserttabledialog', {\n            text: 'Insert table',\n            icon: 'table',\n            onAction: cmd('mceInsertTableDialog'),\n            onSetup: onSetupEditable(editor)\n        });\n        addMenuIfRegistered('tableprops', {\n            text: 'Table properties',\n            onSetup: selectionTargets.onSetupTable,\n            command: 'mceTableProps'\n        });\n        addMenuIfRegistered('deletetable', {\n            text: 'Delete table',\n            icon: 'table-delete-table',\n            onSetup: selectionTargets.onSetupTable,\n            command: 'mceTableDelete'\n        });\n        // if any of the row menu items returned true\n        if (contains(hasRowMenuItems, true)) {\n            editor.ui.registry.addNestedMenuItem('row', {\n                type: 'nestedmenuitem',\n                text: 'Row',\n                getSubmenuItems: constant('tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter')\n            });\n        }\n        if (contains(hasColumnMenuItems, true)) {\n            editor.ui.registry.addNestedMenuItem('column', {\n                type: 'nestedmenuitem',\n                text: 'Column',\n                getSubmenuItems: constant('tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter')\n            });\n        }\n        if (contains(hasCellMenuItems, true)) {\n            editor.ui.registry.addNestedMenuItem('cell', {\n                type: 'nestedmenuitem',\n                text: 'Cell',\n                getSubmenuItems: constant('tablecellprops tablemergecells tablesplitcells')\n            });\n        }\n        editor.ui.registry.addContextMenu('table', {\n            update: () => {\n                // context menu fires before node change, so check the selection here first\n                selectionTargets.resetTargets();\n                // ignoring element since it's monitored elsewhere\n                return selectionTargets.targets().fold(constant(''), (targets) => {\n                    // If clicking in a caption, then we shouldn't show the cell/row/column options\n                    if (name(targets.element) === 'caption') {\n                        return 'tableprops deletetable';\n                    }\n                    else {\n                        return 'cell row column | advtablesort | tableprops deletetable';\n                    }\n                });\n            }\n        });\n        const tableClassList = filterNoneItem(getTableClassList(editor));\n        if (tableClassList.length !== 0 && editor.queryCommandSupported('mceTableToggleClass')) {\n            editor.ui.registry.addNestedMenuItem('tableclass', {\n                icon: 'table-classes',\n                text: 'Table styles',\n                getSubmenuItems: () => buildMenuItems(editor, tableClassList, 'tableclass', (value) => editor.execCommand('mceTableToggleClass', false, value)),\n                onSetup: selectionTargets.onSetupTable\n            });\n        }\n        const tableCellClassList = filterNoneItem(getCellClassList(editor));\n        if (tableCellClassList.length !== 0 && editor.queryCommandSupported('mceTableCellToggleClass')) {\n            editor.ui.registry.addNestedMenuItem('tablecellclass', {\n                icon: 'table-cell-classes',\n                text: 'Cell styles',\n                getSubmenuItems: () => buildMenuItems(editor, tableCellClassList, 'tablecellclass', (value) => editor.execCommand('mceTableCellToggleClass', false, value)),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n        }\n        // TODO: TINY-8172 Unwind this when an alternative solution is found\n        if (editor.queryCommandSupported('mceTableApplyCellStyle')) {\n            editor.ui.registry.addNestedMenuItem('tablecellvalign', {\n                icon: 'vertical-align',\n                text: 'Vertical align',\n                getSubmenuItems: () => buildMenuItems(editor, verticalAlignValues, 'tablecellverticalalign', applyTableCellStyle(editor, 'vertical-align')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addNestedMenuItem('tablecellborderwidth', {\n                icon: 'border-width',\n                text: 'Border width',\n                getSubmenuItems: () => buildMenuItems(editor, getTableBorderWidths(editor), 'tablecellborderwidth', applyTableCellStyle(editor, 'border-width')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addNestedMenuItem('tablecellborderstyle', {\n                icon: 'border-style',\n                text: 'Border style',\n                getSubmenuItems: () => buildMenuItems(editor, getTableBorderStyles(editor), 'tablecellborderstyle', applyTableCellStyle(editor, 'border-style')),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addNestedMenuItem('tablecellbackgroundcolor', {\n                icon: 'cell-background-color',\n                text: 'Background color',\n                getSubmenuItems: () => buildColorMenu(editor, getTableBackgroundColorMap(editor), 'background-color'),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n            editor.ui.registry.addNestedMenuItem('tablecellbordercolor', {\n                icon: 'cell-border-color',\n                text: 'Border color',\n                getSubmenuItems: () => buildColorMenu(editor, getTableBorderColorMap(editor), 'border-color'),\n                onSetup: selectionTargets.onSetupCellOrRow\n            });\n        }\n        addToggleMenuIfRegistered('tablecaption', {\n            icon: 'table-caption',\n            text: 'Table caption',\n            command: 'mceTableToggleCaption',\n            onSetup: selectionTargets.onSetupTableWithCaption\n        });\n        addToggleMenuIfRegistered('tablerowheader', {\n            text: 'Row header',\n            icon: 'table-top-header',\n            command: 'mceTableRowType',\n            onAction: changeRowHeader(editor),\n            onSetup: selectionTargets.onSetupTableRowHeaders\n        });\n        addToggleMenuIfRegistered('tablecolheader', {\n            text: 'Column header',\n            icon: 'table-left-header',\n            command: 'mceTableColType',\n            onAction: changeColumnHeader(editor),\n            onSetup: selectionTargets.onSetupTableRowHeaders\n        });\n    };\n\n    const Plugin = (editor) => {\n        const selectionTargets = getSelectionTargets(editor);\n        register(editor);\n        registerCommands(editor);\n        addMenuItems(editor, selectionTargets);\n        addButtons(editor, selectionTargets);\n        addToolbars(editor);\n    };\n    var Plugin$1 = () => {\n        global$3.add('table', Plugin);\n    };\n\n    Plugin$1();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"table\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/table')\n//   ES2015:\n//     import 'tinymce/plugins/table'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["type", "all", "name", "key", "get", "set", "parent", "children", "size", "is", "ancestor", "selector", "cell", "rows", "columns", "cells", "table", "detail", "document", "universe", "child", "head", "bounds", "last", "ephemera", "rgbaColour", "api", "dom", "elm", "hasAdvancedRowTab", "hasAdvancedCellTab", "targets"]
}
