import type { AgCartesianAxisPosition, AgTimeInterval, AgTimeIntervalUnit } from 'ag-charts-types';
import type { AxisContext } from '../../module/axisContext';
import type { ModuleContext } from '../../module/moduleContext';
import { type FromToDiff } from '../../motion/fromToMotion';
import type { Scale } from '../../scale/scale';
import { BBox } from '../../scene/bbox';
import { TranslatableGroup } from '../../scene/group';
import { Selection } from '../../scene/selection';
import { Line } from '../../scene/shape/line';
import type { AxisPrimaryTickCount } from '../../util/secondaryAxisTicks';
import { StateMachine } from '../../util/stateMachine';
import { Caption } from '../caption';
import type { ChartAnimationPhase } from '../chartAnimationPhase';
import type { ChartLayout } from '../chartAxis';
import { ChartAxisDirection } from '../chartAxisDirection';
import type { AnimationManager } from '../interaction/animationManager';
import { Axis, type LabelNodeDatum } from './axis';
import { type AxisLineDatum, NiceMode, type TickDatum } from './axisUtil';
import { CartesianAxisLabel } from './cartesianAxisLabel';
type AxisAnimationState = 'empty' | 'ready';
type AxisAnimationEvent = {
    reset: undefined;
    resize: undefined;
    update: FromToDiff;
};
interface GeneratedTicks {
    ticks: TickDatum[];
    tickLines: AxisLineDatum[];
    gridLines: AxisLineDatum[];
    labels: LabelNodeDatum[];
    spacing: number;
}
export declare abstract class CartesianAxis<S extends Scale<D, number, any> = Scale<any, number, any>, D = any> extends Axis<S, D, GeneratedTicks> {
    static is(value: unknown): value is CartesianAxis<any>;
    thickness?: number;
    maxThicknessRatio: number;
    position: AgCartesianAxisPosition;
    protected animationManager: AnimationManager;
    protected readonly headingLabelGroup: TranslatableGroup;
    protected readonly lineNodeGroup: TranslatableGroup;
    protected readonly lineNode: Line;
    protected tickLineGroupSelection: Selection<Line, AxisLineDatum>;
    protected gridLineGroupSelection: Selection<Line, AxisLineDatum>;
    private readonly tempText;
    private readonly tempCaption;
    private readonly tickGenerator;
    protected readonly animationState: StateMachine<AxisAnimationState, AxisAnimationEvent>;
    protected get horizontal(): boolean;
    constructor(moduleCtx: ModuleContext, scale: S);
    protected onGridVisibilityChange(): void;
    resetAnimation(phase: ChartAnimationPhase): void;
    get direction(): ChartAxisDirection.X | ChartAxisDirection.Y;
    createAxisContext(): AxisContext;
    protected createLabel(): CartesianAxisLabel;
    protected updateDirection(): void;
    calculateLayout(primaryTickCount?: AxisPrimaryTickCount, chartLayout?: ChartLayout): {
        primaryTickCount?: AxisPrimaryTickCount | undefined;
        bbox?: BBox | undefined;
    };
    layoutCrossLines(): void;
    calculateTickLayout(domain: D[], niceMode: NiceMode, visibleRange: [number, number], initialPrimaryTickCount?: AxisPrimaryTickCount): {
        niceDomain: D[];
        tickDomain: D[];
        ticks: D[];
        rawTickCount: number | undefined;
        fractionDigits: number;
        timeInterval: AgTimeInterval | AgTimeIntervalUnit | undefined;
        bbox: BBox;
        layout: GeneratedTicks;
    };
    update(): void;
    private getAxisTransform;
    protected updatePosition(): void;
    private getAxisLineCoordinates;
    private getTickLineBBox;
    protected lineNodeBBox(): BBox;
    protected titleBBox(domain: D[], spacing: number): BBox;
    private tickBBox;
    protected titleProps(caption: Caption, domain: D[], spacing: number): {
        visible: boolean;
        text: string | undefined;
        textBaseline: "top" | "bottom";
        x: number;
        y: number;
        rotationCenterX: number;
        rotationCenterY: number;
        rotation: number;
    };
    private getTickLabelProps;
    protected updateSelections(): void;
    protected updateGridLines(): void;
    protected updateTickLines(): void;
    protected updateTitle(domain: D[], spacing: number): void;
    protected updateLabels(): void;
    private animateReadyUpdate;
    protected resetSelectionNodes(): void;
}
export {};
